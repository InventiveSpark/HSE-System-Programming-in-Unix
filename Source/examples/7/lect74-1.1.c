/*
  Пусть на диске в текущем каталоге находится файл a.txt с правами доступа 0600
  (владелец может читать и писать в этот файл), в котором содержится запись:
  “Good morning my friend” (22 символа).
*/

// Заголовочные файлы:
#include <string.h>   /* Содержит прототипы функций работы со строками string(), 
                         strcasecmp(), strcat(), strcpy(), memset(), bzero() и т.д. */
#include <fcntl.h>    // Описание макросов для режимов открытия файлов
#include <unistd.h>   /* Для возможности мобильного переноса с одной вычислительной 
                         платформы на другую */

#include <stdio.h>    /* Для поддержания стандартного ввода-вывода. Включает функции 
                         scanf(), printf(), fgets(), fputs() и др. Функции stdio 
                         наслаиваются поверх СВ ввода-вывода (open(), close(), read(), 
                         write() и т.д.). */                         
void main()
{
   // Выделение памяти под переменные:
   // Символьный массив-буфер
   char buf[80];
   // Переменная для сохранения кода возврата СВ read()
   int result;
   /* Поскольку могут быть предоставлены грязные страницы памяти, то прежде чем
      использовать выделенную память, желательно ее очистить с помощью функции
      memset() или bzero(), занося нулевые значения в область памяти: */
   memset(buf, 80, 0);
   /* Процесс открывает для чтения файл a.txt, номер пользовательского дескриптора
      файла сохраняется в переменную fd: */
   int fd = open("a.txt", 0);       // fd = 3
   /* По умолчанию при открытии файла указатель чтения/записи всегда устанавливается
      на первый (с нулевым индексом) байт файла. */
   printf("Файл открыт для чтения, позиция указателя %ld \n", lseek(fd, 0, SEEK_CUR));

   /* СВ read() читает цепочку заданной длины (50 байтов) из любых символов: */
   result = read(fd, &buf[0], 50);  /* эквивалентно read(fd, buf, 50); = 22,
                                       т.е. сколько байтов было в файле. После
                                       выполнения СВ read() указатель чтения/записи
                                       отсчитал 22 байта от начала файла и уткнулся 
                                       в конец файла. */
   printf("прочитано байт %d, позиция указателя %ld \n", result, lseek(fd, 0, SEEK_CUR));
   result = read(fd, &buf[23], 50); /* = 0. При начале попытки чтения достигнут 
                                       конец файла. Указатель чтения/записи все так
                                       же установлен на 22 байт от начала файла. */
   printf("прочитано байт %d, позиция указателя %ld \n", result, lseek(fd, 0, SEEK_CUR));
}
