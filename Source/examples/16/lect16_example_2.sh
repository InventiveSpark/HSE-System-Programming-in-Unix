: '
Пример 2. Реализация многозадачного приложения

Написать программу поиска в текущем каталоге файлов, созданных за последнюю неделю, размер 
которых превышает 55 байт. Полученную информацию переслать через межпроцессный канал в 
параллельный процесс, где изменить права доступа выделенных файлов на введенные с клавиатуры.
Предусмотреть возможность неоднократного прерывания по сигналу SIGINT. При каждом прерывании 
осуществлять вывод имен тех файлов, у которых изменены права доступа.
'
# Обработчик сигнала - функция prer:
prer() {
    if test -s a.txt; then # Если файл a.txt существует в текущей директории и его размер больше
                           # нуля (он содержит нужную информацию),
        cat a.txt          # то выводятся имена файлов (содержимое этого файла), у которых 
                           # изменены права доступа
    else                   # Если файл a.txt пустой или он не существует
        echo "\nПрава доступа пока не менялись"
    fi
    if [ $flag -eq 0 ]; then # Если ввод еще не произведен, то запрос повторяется:
        echo "Введите права доступа для файлов"
    fi
}
: '
Установка нового обработчика prer при поступлении сигнала прерывания SIGINT (код 2), 
по умолчанию вызывающего завершение процесса при нажатии < Ctrl+C > в терминале.
'
trap "prer" SIGINT

# Основная программа:
flag=0 # Переменная для фиксации факта ввода пользователя
: '
В файл a.txt будут записаны имена файлов, права доступа у которых изменены.
Поскольку будет использоваться мягкое перенаправление (дописывание) в файл a.txt, 
то в случае, если он уже существует, дописывание в него может дать неверный 
результат на выходе, т.е. он будет включать посторонние данные.
'
if test -s a.txt; then # Поэтому, если файл a.txt уже существует в текущей директории 
                       # и его размер больше нуля,
    rm a.txt           # то он удаляется
fi
echo "Введите права доступа для файлов"
read b # Чтение в переменную $b прав доступа, введенных с терминала
flag=1 # Ввод произведен
# Если во время ввода поступит сигнал, то значение флага не изменится. Если ввод завершится 
# успешно, то флаг станет равным единице.
: '
Утилита find предусматривает неограниченное количество аргументов и применяется для поиска 
в текущем каталоге всех файлов размером больше 55 байт, которые были изменены за последнюю 
неделю:
. (каталог поиска) - это отправной каталог (текущий каталог), с которого find начинает поиск
файлов по всем подкаталогам, находящимся внутри.
параметр -type f - искать только обычные файлы.
критерий -size + - искать файлы больше заданного размера (c - размер задан в байтах).
критерий -mtime - - поиск по времени модификации файла, заданным в количестве прошедших суток; 
знак минус и цифра семь определяют время, меньшее или равное аргументу (найти файлы, которые 
обновлялись в течение последних семи дней).
Примечание: Результат, аналогичный полученному командой find можно получить с помощью 
комбинации утилит du и ls, организовав конвейер.
Результат работы утилиты find через межпроцессный канал (с помощью конвейеризации) передается 
утилите tr, которая меняет все символы перевода строки на пробелы.
Эта замена производится потому, что утилита find каждое имя файла выводит в отдельной строке, 
а чтение всей информации будет единожды производиться с помощью конструкции read, которая 
считывает до перевода на новую строку.
Затем имена файлов, разделенные пробелами, передаются через межпроцессный канал (с помощью 
конвейеризации). 
Стоит отметить, что данный подход не позволит корректно обрабатывать файлы, в именах которых 
содержатся символы пробела, т.к. каждое слово в именах таких файлов будет обрабатываться
как отдельный файл.
'
find . -type f -size +55c -mtime -7 | tr "\n" " " | (
    # Код процесса-сына:
    read a          # Считываение всех данных из межпроцессного канала в переменную $a
    for i in $a; do # Цикл по переменной $a, значение переменной $i будет принимать имена файлов
        sleep 2     # Замедление выполнения работы программы на 2 секунды для того, чтобы 
                    # пользователь успел нажать < Ctrl+C >
        chmod $b $i # К файлам с именем в переменной $i права доступа изменяются на права, 
                    # находящиеся в переменной $b
        # При успешном выполнении любая утилита возвращает ноль, поэтому с помощью конструкции 
        # test проверятся возвращаемое значение последней команды $?
        if test $? -eq 0; then # Если возвращаемое значение последней команды равняется нулю, 
            echo $i >>a.txt    # то имя файла $i дописывается (мягкое перенаправление) 
                               # в файл a.txt
        else # В противном случае сообщается, что утилита chmod не выполнилась (пользователь 
             # не является владельцем этого файла и не может изменить права доступа к нему)
            echo "Некорректные права доступа"
        fi
    done # Выход из цикла после изменения прав доступа у файла
)
