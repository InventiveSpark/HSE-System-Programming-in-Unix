: '
Пример 1. Реализация многозадачного приложения

Написать программу определения типа файла, указанного при запросе. Предусмотреть обработку 
сигнала прерывания от клавиатуры. При поступлении 3-х сигналов вывести все файлы текущего
каталога, написанные на языке программирования С.
'

# Обработчик сигнала - функция handl:
i=0 # Счетчик сигналов прерывания
handl() {
    i=`expr $i + 1` # Счетчик сигналов прерывания увеличивается. Альтернативные записи:
                    # i=$(expr $i + 1) и let "i=i+1"
    if test $i -eq 3; then # При поступлении 3-х сигналов (сравниваются числовые выражения)
        file * | grep "C source" | cut -d : -f 1 # Вместо "C source" может быть "C program"
                                                 # - в зависимости от ОС
        : ' Утилита
        file *
        в каждом из файлов текущего каталога анализирует первые 10 записей и выводит имя 
        файла, затем символ двоеточия, затем тип этого файла и другую информацию.
        Организован конвейер: результат команды file передается через межпроцессный канал 
        по конвейеру на вход утилиты grep, которая выводит только те записи, которые 
        содержат шаблон "C source":
        | grep "C source"
        Затем полученный набор записей, содержащих искомый шаблон передается по конвейеру 
        на вход утилиты cut, которая вырезает первый столбец до символа разделения ":"
        | cut -d : -f 1
        Результат выполнения конвейера из трех утилит выведет имена всех файлов текущего 
        каталога, написанных на языке программирования С.
        '
    fi
    if [ $flag -eq 0 ]; then # Если ввод еще не произведен, то запрос повторяется:
        echo -e "введите имя файла:"
    fi
}
: '
Установка нового обработчика handl при поступлении сигнала прерывания SIGINT (код 2), 
по умолчанию вызывающего завершение процесса при нажатии < Ctrl+C > в терминале.
'
trap "handl" SIGINT

# Основная программа:
flag=0                       # Переменная для фиксации факта ввода пользователя
echo -e "введите имя файла:" # Опция "-e" включает поддержку вывода Escape последовательностей
read name                    # Чтение в переменную name имени файла, введенного с терминала
flag=1                       # Ввод произведен
# Если во время ввода поступит сигнал, то значение флага не изменится. Если ввод завершится 
# успешно, то флаг станет равным единице.

: '
Утилита
ls -lda
выводит имена всех файлов в текущем каталоге, включая скрытые файлы, имена которых начинаются 
с точки. Рассмотрим, за что отвечает каждый флаг по отдельности:
флаг l выводит подробной информации о файлах^
-l - выводить список с подробной информацией о файлах - владелец, группа, права доступа, время 
последнего обновления, размер и др.;
-d - выводить только информацию о директории, без ее содержимого (подавляет вывод общего размера 
всех файлов в каждом подкаталоге), полезно при рекурсивном выводе;
-a - отображать все файлы, включая скрытые, имена которых начинаются с точки.
Добавление переменной $name с именем файла выведет информацию только об этом файле или каталоге.
Организован конвейер: результат команды ls передается через межпроцессный канал по конвейеру на 
вход утилиты cut, которая вырезает первый байт из полученной записи:
| cut -c 1-1
В итоге, shell-переменная b будет содержать результат выполнения конвейера из двух утилит 
ls и cut - один символ, характеризующий тип файла $name.
'
b=`ls -lda $name | cut -c 1-1`

: '
Определение типа файла исходя из символа, содержащегося в shell-переменной $b. Как только 
значение shell-переменной или shell-выражения (case <переменная или выражение>) будет совпадать 
с shell-переменной или shell-выражением в одной из моделей, то сразу же будет осуществляется 
выход из конструкции case:
'
case $b in
    '-') echo "файл $name – обычный" ;;
    'd') echo "файл $name – директория" ;;
    'p') echo "файл $name – канал" ;;
    'с') echo "файл $name – специальный байт-ориентированный файл" ;;
    'b') echo "файл $name – специальный блок-ориентированный файл" ;;
    's') echo "файл $name – сокет (гнездо)" ;;
    'l') echo "файл $name – символьная ссылка" ;;
    *) default ;;
esac
