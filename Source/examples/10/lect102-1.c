/*
   Пример реализации обработки сигналов на процедурном языке.
   Обработка сигнала SIGINT.
*/

// Заголовочные файлы:
#include <stdio.h>  // Для поддержания стандартного ввода-вывода
#include <signal.h> /* Для работы с сигнальной маской процесса и макросами, 
                       прототипами данных из функции sigaction() */

/* Глобальная переменная n, видимая всем функциям данной программы,
   выполняет роль счетчика сигналов: */
int n = 0;

/* Функция обработки сигнала func() должна быть описана или
   объявлена перед использованием СВ signal() или sigaction(): */
void func()
{
    /* Тело программы обработчика */
    /* Счетчик сигналов прерывания увеличивается при поступлении
       каждого сигнала, и на экран выводится сообщение: */
    n = n + 1;
    printf("Поступил сигнал №: %d\n", n);
}

int main()
{
    /* Настройка обработчика сигнала: */

    /* Выделяется память под два объекта типа struct sigaction, каждый объект 
       такого типа содержит 3 поля. В объекте n будет указан новый метод 
       обработки сигнала, а в объекте o - сохранен старый метод обработки 
       сигнала, который в коде данной программы не используется. */
    struct sigaction n, o;
    /* Могут быть предоставлены грязные страницы памяти, поэтому используя 
       функцию sigemptyset сбрасываются (обнуляются) все биты в переменной sa_mask
       из объекта n. В эту переменную затем будет записана сигнальная маска (СМ)
       текущего процесса. Если СМ не записывать, а оставить очищенную переменную 
       sa_mask как есть, то дополнительных обрабатываемых сигналов к СМ процесса 
       перед вызовом функции-обработчика func() добавлено не будет.
       Напомним, что если определенный бит маски установлен, соответствующий 
       ему сигнал будет обработан. Например, если значение бита в СМ (например 
       2-ого бита) равно 1, то процесс ожидает сигнал с соответствующим кодом 
       (SIGINT) и обязан прореагировать на его поступление.
       Если же значение бита в СМ равно 0, то процесс игнорирует этот сигнал. */
    sigemptyset(&n.sa_mask);
    /* Задаются поля структуры struct sigaction:
       Сохранение текущей СМ. Первые 2 аргумента нулевые, т.е. СМ текущего 
       процесса не будет изменяться, а будет записана в переменную n.sa_mask. */
    sigprocmask(0, 0, &n.sa_mask);
    /* Поскольку при создании процесс-потомок наследует СМ своего родителя, то 
       весь перечень сигналов, которые поддерживаются ОС, отражен в СМ процесса,
       и ОС должна на него адекватно реагировать. */
    /* В поле sa_handler указывается имя (адрес) функции обработки сигнала, 
       описанной в начале программы: */
    n.sa_handler = func;
    /* Поле sa_flags = 0, т.е. предусматривается стандартная обработка сигнала,
       который будет указан в СВ sigaction(). */       
    n.sa_flags = 0;
    /* После того, как заполнены все три поля нового метода обработки сигнала n,
       исполняется СВ sigaction(), первым аргументом которого является SIGINT 
       (код 2) - сигнал прерывания < Ctrl+C > с терминала, по умолчанию 
       вызывающий завершение процесса.
       Вторым аргументом является n - новый метод обработки сигнала.
       Третий аргумент o означает, что старый метод обработки сигнала будет 
       сохранен в объекте o, хотя он и не будет использоваться в дальнейшем.
       Поле n.sa_mask определяет набор сигналов, которые будут добавлены к СМ
       процесса перед вызовом функции-обработчика n.sa_handler = func(). Перед
       возвратом из обработчика сигнала СМ будет автоматически восстановлена в 
       прежнее состояние. Таким способом можно блокировать определенные сигналы 
       на время работы функции-обработчика.
       Перед доставкой сигнала, когда вызывается функция-обработчик, сам сигнал 
       также включается в СМ; тем самым на время выполнения обработчика 
       блокируется доставка того же самого сигнала. Такой подход гарантирует 
       то, что во время обработки последующее поступление определенных сигналов 
       будет приостановлено до завершения вызова. */
    if (sigaction(SIGINT, &n, &o) == -1)
        printf("Ошибка в sigaction\n");
    /* СВ sigaction() описан в начале программы, поэтому, если в дальнейшем 
       поступит сигнал SIGINT, то программа всегда на него отреагирует: любое
       нажатие < Ctrl+C > на клавиатуре вызовет функцию-обработчик func(), которая
       при каждом прерывании будет увеличивать счетчик сигналов, которые получил
       данный процесс и выводить значение счетчика на экран. */

    /* Тело основной программы: */
    /*  Бесконечный цикл для того, чтобы пользователь успел нажать < Ctrl+C >: */
    while (1);
    return 0; // Код 0 означает успешное завершение работы процесса.
}