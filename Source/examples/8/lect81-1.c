/*
  Создание межпроцессного канала. 
  Общепринятый метод создания каналов состоит в следующем: программа создает 
  канал по системному вызову pipe(), после чего разделяется на две копии 
  с помощью СВ fork(). Затем в одном из полученных процессов закрывается 
  сторона канала для чтения -  fd[0], а в другом процессе - сторона канала
  для записи - fd[1]. После чего по созданному однонаправленному каналу 
  производиться обмен информацией между родительским и дочерним процессами.
*/

// Заголовочные файлы
#include <unistd.h>   /* Для возможности мобильного переноса с одной вычислительной 
                         платформы на другую */
void main()
{
    // Выделение памяти под переменные:
    int fd[2]; /* Для хранения пользовательских файловых дескрипторов 
                  межпроцессного канала, открываемого СВ pipe(). */
    /* Для каждого процесса изначально открыты три основных файла потоков, которые могут
       использовать программы, они идентифицируются по номеру пользовательского 
       дескриптора файла:
       STDIN или 0  -  этот файл связан с клавиатурой, и большинство команд получают 
                       данные для работы отсюда;
       STDOUT или 1 -  это стандартный вывод, сюда программа отправляет все результаты 
                       своей работы. Он связан с экраном или, если быть точным, 
                       с терминалом, в котором выполняется программа;
       STDERR или 2 -  все сообщения об ошибках выводятся в этот файл.

       СВ pipe() создает межпроцессный канал и открывает два пользовательских дескриптора
       файлов - fd[0] с доступом к каналу на чтение и fd[1] с доступом на запись, которые
       будут записаны в ТПДОФ (таблицу пользовательских дескрипторов открытых файлов) 
       процесса под новыми номерами 3 и 4, соответственно: */
    pipe(fd);
    /* С помощью СВ fork() текущий процесс разделяется на две идентичные копии,  
       которые продолжают выполняться как два независимых процесса:
       1) Процесс-потомок получает от СВ fork() код ответа 0.
       2) Процесс-родитель - идентификатор, под которым запущен процесс-потомок. 
       В случае аварийного завершения СВ fork() вернет -1. */
    if (fork() == 0)
    {   // Ветка для потомка после успешного вызова fork():
        // Закрытие файлового дескриптора канала, предназначенного для записи:
        close(fd[1]);
        // Теперь потомок может только читать информацию от родителя...
    }
    else
    {   // Ветка для родителя после успешного вызова fork():
        // Закрытие файлового дескриптора канала, предназначенного для чтения:
        close(fd[0]);
        // Теперь родитель может только передавать информацию потомку...
    }
    /* Примечание: чтобы организовать передачу в обратном направлении, родительский
       процесс закрывает fd[1], а дочерний процесс - fd[0]. */
}
