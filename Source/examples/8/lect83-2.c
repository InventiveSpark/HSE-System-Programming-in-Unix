/*
  Передача информации через межпроцессный канал. Пример реализации.
  Пример 2 с перенаправлением вывода.

  Ответ:
  n = 20, но под  Ubuntu Linux n = 38 (зависит от кодировки)
  n = 0 stat = 256
*/

// Заголовочные файлы
#include <stdio.h>       /* Для поддержания стандартного ввода-вывода. Включает функции 
                            scanf(), printf(), fgets(), fputs() и др. Функции stdio 
                            наслаиваются поверх СВ ввода-вывода (open(), close(), read(), 
                            write() и т.д.). */
#include <sys/types.h>
#include <unistd.h>      /* Для возможности мобильного переноса с одной вычислительной 
                            платформы на другую */  
#include <sys/wait.h>    /* Для СВ wait(), позволяющего процессу-родителю дождаться 
                            момента, когда процесс-потомок выполнит работу и пришлет 
                            результаты своей работы */
#include <string.h>      /* Содержит прототипы функций работы со строками string(), 
                            strcasecmp(), strcat(), strcpy(), memset(), bzero() и т.д. */
#include <stdlib.h>      // Для библиотечной функции exit()                            
                                                      
void main()
{
    /* Выделение памяти под переменные:
     fd[2] - для  хранения пользовательских файловых дескрипторов межпроцессного канала,
             открываемого СВ pipe(). 
     stat  - для хранения причины гибели процесса-сына, записанного СВ wait().
     n     - для сохранения кода возврата СВ read(). */
    int fd[2], stat, n;
    char buf[80];    // Символьный массив-буфер
    /* Поскольку могут быть предоставлены грязные страницы памяти, то прежде чем
       использовать выделенную память, желательно ее очистить с помощью функции
       memset() или bzero(), занося нулевые значения в область памяти: */
    memset(buf, 80, 0);
    /* Для каждого процесса изначально открыты три основных файла потоков, которые могут
       использовать программы, они идентифицируются по номеру пользовательского 
       дескриптора файла:
       STDIN или 0  -  этот файл связан с клавиатурой, и большинство команд получают 
                       данные для работы отсюда;
       STDOUT или 1 -  это стандартный вывод, сюда программа отправляет все результаты 
                       своей работы. Он связан с экраном или, если быть точным, 
                       с терминалом, в котором выполняется программа;
       STDERR или 2 -  все сообщения об ошибках выводятся в этот файл.

       СВ pipe() создает межпроцессный канал и открывает два пользовательских дескриптора
       файлов - fd[0] с доступом к каналу на чтение и fd[1] с доступом на запись, которые
       будут записаны в ТПДОФ (таблицу пользовательских дескрипторов открытых файлов) 
       процесса под новыми номерами 3 и 4, соответственно: */    
    pipe(fd);
    /* С помощью СВ fork() текущий процесс разделяется на две идентичные копии,  
       которые продолжают выполняться как два независимых процесса:
       1) Процесс-потомок получает от СВ fork() код ответа 0.
       2) Процесс-родитель - идентификатор, под которым запущен процесс-потомок. 
       В случае аварийного завершения СВ fork() вернет -1.
       Оба процесса параллельные, идентичные, включая переменные, регистры и ТПДОФ 
       (у родителя и потомка открыты одни и те же файлы). У них есть общий файл канала. 
       У каждого из процессов в ТПДОФ есть два пользовательских дескриптора с 
       номерами fd[0] и fd[1], соответствующих этому файлу. */    
    if (fork() == 0)
    {   // Ветка для потомка после успешного вызова fork():
        // Закрытие файлового дескриптора канала, предназначенного для чтения:
        close(fd[0]);
        // Теперь потомок может только передавать информацию родителю...
        // Закрытие дескриптора файла стандартного вывода STDOUT_FILENO = 1:
        close(1);
        /* Отождествление стандартного вывода с файловым дескриптором канала, 
           предназначенным для записи. Для этого посредством СВ dup() выполняется 
           копирование дескриптора канала, предназначенного для записи, в первую 
           (наименьшую) свободную запись в ТПДОФ (таблице пользовательских дескрипторов
           открытых файлов) процесса (начиная от 0), т.е. в STDOUT_FILENO = 1, поскольку
           STDIN_FILENO = 0 занят, а дескриптор файла стандартного вывода с номером 1
           был предварительно закрыт.
        */
        dup(fd[1]);
        /* Закрытие лишней копии файлового дескриптора канала, предназначенного 
           для записи: */
        close(fd[1]);
        /* Осуществлено перенаправление вывода. Вместо файла стандартного вывода, которым
           является монитор, установлен межпроцессный канал, который открыт на запись,
           поэтому результат выполнения любой стандартной инструкции, функции или утилиты
           будет выводиться не на экран монитора, а в межпроцессный канал. 
           В межпроцессный канал (в стандартный поток вывода вместо экрана) посредством 
           функции printf() через буферизированный вывод выводится сообщение: */
        printf("Получите информацию\n");
        exit(1);
        /* Библиотечная функция exit() сбрасывает буферы ввода-вывода и завершает процесс, 
           закрывая все открытые в процессе файлы; код 1 означает успешное завершение 
           работы процесса. Благодаря сбрасыванию буферов, буфер от функции printf() 
           будет вытолкнул в канал. После завершения процесса-потомка канал закрыт на 
           чтение и на запись и ТПДОФ процесса-потомка полностью пустая.*/
    }
    else
    {   // Ветка для родителя после успешного вызова fork():
        /* Данная часть кода процесса-родителя выполняется параллельно с выполнением
           процесса-потомка:
           Закрытие файлового дескриптора канала, предназначенного для записи. Теперь
           родитель может только читать информацию от потомка...*/
        close(fd[1]);
        /* Процесс-родитель выполняет СВ wait() и ждет завершения выполнения 
           процесса-потомка. */
        wait(&stat); // stat = 256
        /* Дождавшись, когда процесс-потомок завершится, процесс-родитель может прочитать 
           информацию из канала и проанализировать ее.
           СВ wait() возвращает идентификатор завершившегося процесса-потомка (в данном
           примере идентификатор не запоминается, т.к. порождается всего один потомок
           и нет нужды различать, какой именно потомок завершил свое существование) и 
           в свой единственный аргумент stat записывает причину гибели процесса-потомка.
           В ОС семейства UNIX процесс может завершиться либо с помощью сигнала (сигнал 
           - программная версия аппаратных прерываний), либо по СВ _exit().
           Т.к. процесс-потомок завершается с помощью библиотечной функции exit(), 
           которая завершается с аргументом 1, следовательно stat = 256, т.к. аргумент 
           функции exit() записывается с 8 по 15 биты (биты с 0 по 7 заполняются тогда, 
           когда процесс убивается сигналом и в них записываются номер сигнала и действия 
           процесса по сигналу). Следовательно, единица, записанная в двоичной системе 
           исчисления в 8 бит:
           stat = 00000001 0 0000000 (2) = 256 (10) */
        /* СВ read() читает из межпроцессного канала цепочку заданной длины (80 байтов), 
           состоящую из любых символов, и записывает их в буфер buf. Переменная n будет
           хранить число байт, успешно прочитанных СВ read() из межпроцессного канала.
           Поскольку в файле межпроцессного канала меньше, чем 80 байт, то СВ read()
           прочитает все данные и вернет число меньше 80, а указатель чтения/записи
           уткнется в конец файла: */
        n = read(fd[0], buf, 80);
        /* На экран (в стандартный поток вывода) посредством функции printf() через 
           буферизированный вывод выводится количество байт, прочитанных из 
           межпроцессного канала: */
        printf("n = %d\n", n); // n = 20, но под Ubuntu Linux n = 38 (зависит от кодировки)
        /* После того, как уже были прочитаны все данные, при повторной попытке чтения  
           встретится признак конца файла и СВ read() вернет 0. Указатель чтения/записи 
           все так же будет установлен в конец файла: */
        n = read(3, &buf[n + 1], 80);
        /* На экран (в стандартный поток вывода) посредством функции printf() через 
           буферизированный вывод выводятся: количество байт, прочитанных из 
           межпроцессного канала во второй раз; причина гибели процесса-потомка. */
        printf("n = %d stat = %d\n", n, stat); // n = 0  stat = 256
        /* После закрытия пользовательского дескриптора канала, предназначенного для 
           чтения, межпроцессный канал будет удален, т.к. все процессы, связанные 
           с FIFO файлом межпроцессного канала, закрыли все свои ссылки на него: */
        close(fd[0]);
        /* При завершении процесса все открытые им файлы автоматически закрываются ядром.
           Многие приложения используют это обстоятельство и не закрывают файлы явно.
           Закрытие файла приводит также к снятию любых блокировок, которые могли быть 
           наложены процессом. */
    }
}
