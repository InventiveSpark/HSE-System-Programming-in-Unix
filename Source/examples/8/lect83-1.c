/*
  Передача информации через межпроцессный канал. Пример реализации.
  Пример 1

  Ответ:
  How do you do my friend?k = 25
*/

// Заголовочные файлы
#include <stdio.h>       /* Для поддержания стандартного ввода-вывода. Включает функции 
                            scanf(), printf(), fgets(), fputs() и др. Функции stdio 
                            наслаиваются поверх СВ ввода-вывода (open(), close(), read(), 
                            write() и т.д.). */
#include <sys/types.h>
#include <unistd.h>      /* Для возможности мобильного переноса с одной вычислительной 
                            платформы на другую */  
#include <fcntl.h>       // Для управления файлами
#include <sys/wait.h>    /* Для СВ wait(), позволяющего процессу-родителю дождаться 
                            момента, когда процесс-потомок выполнит работу и пришлет 
                            результаты своей работы */
void main()
{
    /* Выделение памяти под переменные:
     p[2] - для  хранения пользовательских файловых дескрипторов межпроцессного канала,
            открываемого СВ pipe(). 
     s    - для хранения причины гибели процесса-сына, записанного СВ wait().
     k    - для сохранения кода возврата СВ read(). */
    int p[2], s, k;
    char buf[80];    // Символьный массив-буфер
    /* Для каждого процесса изначально открыты три основных файла потоков, которые могут
       использовать программы, они идентифицируются по номеру пользовательского 
       дескриптора файла:
       STDIN или 0  -  этот файл связан с клавиатурой, и большинство команд получают 
                       данные для работы отсюда;
       STDOUT или 1 -  это стандартный вывод, сюда программа отправляет все результаты 
                       своей работы. Он связан с экраном или, если быть точным, 
                       с терминалом, в котором выполняется программа;
       STDERR или 2 -  все сообщения об ошибках выводятся в этот файл.

       СВ pipe() создает межпроцессный канал и открывает два пользовательских дескриптора
       файлов - p[0] с доступом к каналу на чтение и p[1] с доступом на запись, которые
       будут записаны в ТПДОФ (таблицу пользовательских дескрипторов открытых файлов) 
       процесса под новыми номерами 3 и 4, соответственно: */
    pipe(p);
    /* С помощью СВ fork() текущий процесс разделяется на две идентичные копии,  
       которые продолжают выполняться как два независимых процесса:
       1) Процесс-потомок получает от СВ fork() код ответа 0.
       2) Процесс-родитель - идентификатор, под которым запущен процесс-потомок. 
       В случае аварийного завершения СВ fork() вернет -1.
       Оба процесса параллельные, идентичные, включая переменные, регистры и ТПДОФ 
       (у родителя и потомка открыты одни и те же файлы). У них есть общий файл канала. 
       У каждого из процессов в ТПДОФ есть два пользовательских дескриптора с 
       номерами p[0] и p[1], соответствующих этому файлу. */
    if (fork() != 0)
    {   // Ветка для родителя после успешного вызова fork():
        /* Процесс-родитель выполняет СВ wait() и ждет завершения выполнения 
           процесса-потомка. */
        wait(&s); // s = 512
        /* Дождавшись, когда процесс-потомок завершится, процесс-родитель может прочитать 
           информацию из канала и проанализировать ее.
           СВ wait() возвращает идентификатор завершившегося процесса-потомка (в данном
           примере идентификатор не запоминается, т.к. порождается всего один потомок
           и нет нужды различать, какой именно потомок завершил свое существование) и 
           в свой единственный аргумент s записывает причину гибели процесса-потомка.
           В ОС семейства UNIX процесс может завершиться либо с помощью сигнала 
           (сигнал - программная версия аппаратных прерываний), либо по СВ _exit().
           Т.к. процесс-потомок завершается с помощью СВ _exit(), который завершится 
           с аргументом 2, следовательно s = 512, т.к. аргумент СВ _exit() 
           записывается с 8 по 15 биты (биты с 0 по 7 заполняются тогда, когда процесс
           убивается сигналом и в них записываются номер сигнала и действия процесса 
           по сигналу). Следовательно, двойка, записанная в двоичной системе исчисления 
           в 9 и 8 биты:
           s = 00000010 0 0000000 (2) = 512 (10) */
        // Закрытие файлового дескриптора канала, предназначенного для записи:
        close(p[1]);
        // Теперь родитель может только читать информацию от потомка...
        /* СВ read() читает из межпроцессного канала цепочку заданной длины (80 байтов), 
           состоящую из любых символов, и записывает их в буфер buf. Переменная k будет
           хранить число байт, успешно прочитанных СВ read() из межпроцессного канала: */
        k = read(p[0], buf, 80);
        /* СВ write() записывает в файл стандартного вывода цепочку заданной длины 
           (k байт) из символьного массива-буфера buf: */
        write(1, buf, k);   // buf = How do you do my friend?
        /* На экран (в стандартный поток вывода) посредством функции printf() через 
           буферизированный вывод выводится количество байт, прочитанных из 
           межпроцессного канала: */
        printf("k = %d\n", k); // k = 25
        /* При завершении процесса все открытые им файлы автоматически закрываются ядром.
           Многие приложения используют это обстоятельство и не закрывают файлы явно.
           Закрытие файла приводит также к снятию любых блокировок, которые могли быть 
           наложены процессом. */
    }
    else
    {   // Ветка для потомка после успешного вызова fork():
        // Закрытие файлового дескриптора канала, предназначенного для чтения:
        close(p[0]);
        // Теперь потомок может только передавать информацию родителю...
        /* СВ write() записывает в файл межпроцессного канала цепочку заданной длины 
           (25 байт) из символьного массива "How do you do my friend?": */
        write(p[1], "How do you do my friend?", 25);
        _exit(2);
        /* После записи информации в канал процесс-потомок закрывается с помощью 
           СВ _exit(2); код 2 означает успешное завершение работы процесса.
           СВ _exit() завершает текущий процесс, в рамках которого он выполнялся,
           закрывает все открытые в данном процессе файлы и не сбрасывает буферы 
           ввода-вывода. Последнее не важно, т.к. СВ write() не использует
           буферизацию. 
           После завершения процесса-потомка канал закрыт на чтение и на запись, 
           а ТПДОФ процесса-потомка полностью пустая. */ 
    }
}
