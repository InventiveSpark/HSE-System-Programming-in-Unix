/*
  В следующем примере в текущем процессе формируется процесс-сын, который 
  осуществляет выполнение утилиты ls с ключем -a, при этом перенаправляя вывод 
  результатов этой утилиты в файл a.txt, которого до запуска программы 
  не существует.
*/

#include <stdio.h> // SYSTEM V POSIX.1
#include <sys/types.h>
#include <unistd.h>
#include <fcntl.h>
void main()
{
    // Выделение памяти под целочисленные переменные:
    int fd, s, d;
    /* Процесс при помощи СВ fork() разделяется на две идентичные копии,
       которые начинают выполняться параллельно. */
    if (fork() != 0)
    { /* Тело процесса-отца */
        /* Процесс-отец выполняет СВ wait() и ждет завершения выполнения 
           процесса-сына. */
        d = wait(&s);
        printf("s = %d\n", s);
        /*        
           Дождавшись, когда процесс-сын завершится после выполнения СВ execl(),
           процесс-отец может прочитать информацию из файла и проанализировать ее.
           СВ wait() возвращает идентификатор завершившегося процесса-сына и в свой
           единственный аргумент записывает причину гибели процесса-сына.
           Т.к. процесс-сын завершается с помощью СВ execl(), который, в случае
           удачного выполнения завершится с нулевым аргументом, то s = 0. Однако, 
           если произойдет ошибка, то процесс-сын дойдет до СВ _exit(2) и s = 512, 
           т.к. аргумент СВ _exit() записывается с 8 по 15 биты (биты с 0 по 7 
           заполняются тогда, когда процесс убивается сигналом и в них записываются 
           номер сигнала и действия процесса по сигналу). Следовательно, двойка, 
           записанная в двоичной системе исчисления в 9 и 8 биты:
           s = 00000010 0 0000000 (2) = 512 (10)
        */
    }
    else
    { /* Тело процесса-сына */
        /* В текущем каталоге создается файл a.txt с правами доступа 0664: 110 110 100,
           при этом в ТПДОФ процесса-сына появляется соответствующая запись с номером 3, 
           т.к. это порядковый номер первой (наименьшей) свободной записи в ТПДОФ. */
        fd = creat("a.txt", 0664); // fd = 3
        /* Закрывается файловый дескриптор файла стандартного вывода, т.е. 
           освобождается запись с номером 1 в ТПДОФ процесса-сына. */
        close(1);
        /* Запись с номером 1 теперь свободна. В нее копируется пользовательский дескриптор 
           с номером fd. Теперь в ТПДОФ процесса-сына две одинаковые записи под номерами
           fd = 3 и 1. */
        dup2(fd, 1);
        /* В ТПДОФ процесса-сына освобождается запись с номером fd = 3. Теперь в ТПДОФ
           процесса-сына всего три записи с номерами 0, 1 и 2. Причем в записи под номером
           1 вместо файла стандартного вывода (монитора) указан обычный файл a.txt, который 
           открыт также на запись. Так произошло перенаправление стандартного вывода. */
        close(fd);
        /* Выполнение утилиты ls с ключем -a, которая выводит все файлы текущего каталога, 
           включая те файлы, имена которых начинаются с точки (скрытые). Результат выполнения 
           этой инструкции вместо монитора будет выведен в файл a.txt: */
        execl("/bin/ls", "ls", "-a", 0);
        /*
           Стивен Р.У., Раго С.А. UNIX. Профессиональное программирование. 3-е издание.
           - СПб.: Питер, 2018 г., стр. 308-309
           Функция fork часто используется для создания нового процесса, который затем 
           запускает другую программу с помощью одной из функций семейства exec. Когда 
           процесс вызывает одну из функций exeс, он полностью замещается другой программой,
           и эта новая программа начинает выполнение собственной функции main. Идентификатор 
           процесса при этом не изменяется, поскольку функция exec не создает новый процесс, 
           она просто замещает текущий процесс - его сегмент кода, сегмент данных, 
           динамическую область памяти и сегмент стека - другой программой.
        */
        /* Т.к. командная строка у СВ execl() сформирована корректно, то до нижней инструкции
           _exit(2) процесс уже не дойдет. Процесс-сын после выполнения СВ execl() будет
           успешно завершен с помощью СВ _exit(0); код 0 означает правильное завершение 
           программы. */
        _exit(2);
        /* Программа закрывается с помощью СВ _exit(); код 2 означает завершение работы 
           программы, вызванное ошибкой СВ execl(). */
    }
}
