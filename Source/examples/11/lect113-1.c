// Обработчик прерываний. Реализация

/*
Задача:
Написать программу определения типа файла, указанного при запросе. 
Предусмотреть обработку сигнала прерывания от клавиатуры. При поступлении 
3-х сигналов прерывания вывести все файлы текущего каталога, написанные
на языке программирования С (или C++).
*/

// Заголовочные файлы
/* Глобальная переменная count, видимая всем функциям данной программы,
   выполняет роль счетчика сигналов. */


/* Функция обработки сигнала handl() должна быть описана или объявлена перед 
   использованием СВ signal() или sigaction().
   Функция обработки сигнала запускает два процесса-потомка и открывает два 
   межпроцессных канала. Для выполнения задачи достаточно трех процессов:
   1. первый потомок выполняет утилиту file;
   2. второй потомок - grep;
   3. третий (родитель) - cut. */
void handl() // Описание функции обработчика сигнала
{ 
    /* Выделение памяти под переменные для хранения пользовательских файловых 
       дескрипторов двух межпроцессных каналов, открываемых СВ pipe(). Канал p
       будет использован для связи с первым процессом-потомком, канал p1 - для 
       связи со вторым потомком: */
    int p[2], p1[2];
    /* Счетчик сигналов прерывания увеличивается при поступлении каждого сигнала: */
    count++;
    /* При поступлении 3-х сигналов прерывания нужно вывести имена всех файлов 
       текущего каталога, написанных на языке программирования С или C++. 
       Эту информацию можно получить, реализовав конвейерное выполнение трех утилит 
       file (или find, которая работает медленнее), grep и cut:
       "file * | grep "C source" | cut -d : -f 1"
       В некоторых ОС утилита file может выводить "C program", тогда в качестве 
       аргумента утилиты grep вместо шаблона "C source" нужно использовать 
       "C program". */
    if (count == 3)
    {
        /* Первый межпроцессный канал будет использован для общения с первым 
           потомком, который будет создан для выполнения утилиты file.
           СВ pipe() создает первый межпроцессный канал и открывает два 
           пользовательских дескриптора файлов - p[0] с доступом к каналу на чтение
           и p[1] с доступом на запись, которые будут записаны в ТПДОФ (таблицу 
           пользовательских дескрипторов открытых файлов) процесса под новыми 
           номерами 3 и 4, соответственно: */
        pipe(p);
        /* После создания первого межпроцессного канала процесс с помощью СВ fork() 
           разделяется на две идентичные копии, которые продолжают выполняться как 
           два независимых процесса:
           1) Процесс-потомок получает от СВ fork() код ответа 0.
           2) Процесс-родитель - идентификатор, под которым запущен процесс-потомок. 
           В случае аварийного завершения СВ fork() вернет -1. 
           Создание первого процесса-потомка для выполнения утилиты file: */
        if (fork() == 0)
        {   /* Ветка для первого потомка (выполнит утилиту file) после успешного 
               вызова fork():
               Из ТПДОФ процесса-потомка удаляется запись с номером p[0] = 3, т.е. 
               закрывается доступ к межпроцессному каналу на чтение: */
            close(p[0]);
            /* Отождествление стандартного вывода с файловым дескриптором первого 
               канала, предназначенным для записи. Для этого посредством СВ dup2() 
               выполняется принудительное копирование дескриптора канала, 
               предназначенного для записи (запись с номером p[1] = 4), в запись 
               STDOUT_FILENO = 1 из ТПДОФ. Поскольку дескриптор STDOUT_FILENO = 1 
               перед вызовом dup2() был открыт, то он предварительно закрывается: */
            dup2(p[1], 1);
            /* Осуществлено перенаправление вывода. Вместо файла стандартного 
               вывода, которым является монитор, установлен первый межпроцессный 
               канал, который открыт на запись, поэтому результат выполнения любой 
               стандартной инструкции, функции или утилиты будет выводиться не 
               на экран монитора, а в первый межпроцессный канал. 
               СВ system() позволяет вызывающей программе выполнить произвольную 
               консольную команду или вызвать другую программу, не выходя из 
               контекста вызывающего процесса. СВ system() выполняет команду для 
               утилиты "file *", результат работы этой утилиты поступает в 
               первый межпроцессный канал, а не выводится на монитор: */
            system("file *");
            /* Первый процесс-потомок закрывается с помощью СВ _exit(0), который 
               закрывает все открытые в процессе файлы. Код 0 означает правильное 
               завершение процесса-потомка: */
            _exit(0);
        } // Ветка для первого потомка
        else
        { 
            /* Ветка для родителя после успешного вызова fork(). Родитель создаст 
               второго потомка, который выполнит утилиту grep, а затем сам родитель 
               выполнит утилиту cut.
               Вызвав СВ wait(), родитель приостанавливает свою работу и ждет 
               завершения первого процесса-потомка, выполнившего утилиту file.
               Аргумент 0 означает, что причина гибели процесса-потомка (например, 
               по СВ exit() или по сигналу) нам не интересна). Поскольку процесс-
               потомок к данному моменты был всего один, то возвращаемое значение 
               СВ wait() также неважно: */
            wait(0);
            /* Первый канал p в родительском процессе все еще существует, т.к. 
               межпроцессный канал уничтожатся только тогда, когда от него 
               отсоединяются все процессы и, хотя первый потомок завершен, но 
               родительский процесс все еще работает.
               Второй межпроцессный канал будет использован для общения со вторым
               потомком, который будет создан для выполнения утилиты grep.
               После завершения процесса первого потомка, процесс-родитель с помощью
               СВ pipe() создает второй межпроцессный канал и открывает два 
               пользовательских дескриптора файлов - p1[0] с доступом к каналу на 
               чтение и p1[1] с доступом на запись, которые будут записаны в ТПДОФ 
               процесса под новыми номерами 5 и 6, соответственно: */
            pipe(p1);
            /* Сторона первого канала, открытая для записи, больше не нужна, т.к.
               результат работы первого потомка (результат выполнения утилиты file) 
               уже хранится в файле канала с номером пользовательского дескриптора 
               p[0], открытым на чтение.
               Из ТПДОФ процесса-родителя удаляется запись с номером p[1] = 4, т.е. 
               закрывается доступ на запись к первому межпроцессному каналу, 
               использованному для общения с первым потомком: */
            close(p[1]);
            /* После создания второго межпроцессного канала процесс с помощью СВ fork() 
               разделяется на две идентичные копии, которые продолжают выполняться как 
               два независимых процесса:
               1) Процесс-потомок получает от СВ fork() код ответа 0.
               2) Процесс-родитель - идентификатор, под которым запущен процесс-потомок. 
               В случае аварийного завершения СВ fork() вернет -1. 
               Создание второго процесса-потомка для выполнения утилиты grep: */
            if (fork() == 0)
            {   /* Ветка для второго потомка (выполнит утилиту grep) после успешного 
                   вызова fork(): 
                   Из ТПДОФ второго потомка удаляется запись с номером p1[0] = 5, 
                   т.е. закрывается доступ ко второму межпроцессному каналу 
                   на чтение: */
                close(p1[0]);
                /* Отождествление стандартного вывода с файловым дескриптором второго 
                   канала, предназначенным для записи. Для этого посредством СВ dup2() 
                   выполняется принудительное копирование дескриптора канала, 
                   предназначенного для записи (запись с номером p1[1] = 6), в запись 
                   STDOUT_FILENO = 1 из ТПДОФ. Поскольку дескриптор STDOUT_FILENO = 1 
                   перед вызовом dup2() был открыт, то он предварительно закрывается: */
                dup2(p1[1], 1);
                /* Осуществлено перенаправление вывода. Вместо файла стандартного 
                   вывода, которым является монитор, установлен второй межпроцессный 
                   канал, который открыт на запись, поэтому результат выполнения любой 
                   стандартной инструкции, функции или утилиты будет выводиться не 
                   на экран монитора, а во второй межпроцессный канал.
                   Второй потомок должен считать данные от утилиты file и 
                   использовать их в качестве входных для выполнения утилиты grep.
                   Поэтому производится отождествление стандартного ввода с файловым 
                   дескриптором первого канала, предназначенным для чтения. 
                   Для этого посредством СВ dup2() выполняется принудительное 
                   копирование дескриптора первого канала, предназначенного для 
                   чтения (запись с номером p[0] = 3), в запись STDIN_FILENO = 0 из 
                   ТПДОФ. Поскольку дескриптор STDIN_FILENO = 0 перед вызовом dup2()
                   был открыт, то он предварительно закрывается: */
                dup2(p[0], 0);
                /* Осуществлено перенаправление ввода. Вместо файла стандартного 
                   ввода, которым является клавиатура, установлен первый 
                   межпроцессный канал, который открыт на чтение. Теперь данные, 
                   полученные от утилиты file, которые содержатся в первом 
                   межпроцессном канале, будут поступать из стандартного ввода 
                   в утилиту grep. 
                   В результате выполненных перенаправлений ввода-вывода, утилита 
                   grep считает данные из первого канала p[0] и выведет данные во 
                   второй канал p1[1].
                   СВ system() позволяет вызывающей программе выполнить произвольную 
                   консольную команду или вызвать другую программу, не выходя из 
                   контекста вызывающего процесса. СВ system() выполняет команду для 
                   утилиты "grep "C source"", результат работы этой утилиты поступает
                   во второй межпроцессный канал, а не выводится на монитор: */
                system("grep \"C source\"");
                /* Шаблон "C source" для утилиты grep состоит из двух слов. Шаблон, 
                   состоящий из двух слов и более необходимо обрамлять кавычками. 
                   Левый слеш используется для экранирования символа двойных 
                   кавычек, чтобы внутри одних кавычек сохранились вторые, вложенные
                   кавычки.
                   Второй процесс-потомок закрывается с помощью СВ _exit(1), который 
                   закрывает все открытые в процессе файлы. Код 1 означает 
                   правильное завершение процесса-потомка: */
                _exit(1);
            }
            else
            {   
                /* Ветка для родителя после успешного вызова второго СВ fork(). 
                   Продолжение кода родительского процесса, в котором он выполнит
                   утилиту cut. */
                /* Вызвав СВ wait(), родитель приостанавливает свою работу и ждет 
                   завершения второго процесса-потомка, выполнившего утилиту grep.
                   Аргумент 0 означает, что причина гибели процесса-потомка 
                   (например, по СВ exit() или по сигналу) нам не интересна). 
                   Поскольку первый процесс-потомок к данному моменты был уже 
                   завершен и остался только второй потомок, то возвращаемое 
                   значение СВ wait() также неважно: */
                wait(0);
                /* К данному моменту завершились оба процесса-потомка.
                   Из ТПДОФ родительского процесса удаляется запись с номером 
                   p1[1] = 6, т.е. закрывается доступ на запись ко второму 
                   межпроцессному каналу, использованному для общения со вторым 
                   потомком: */
                close(p1[1]);
                /* Родитель должен считать данные от утилиты grep и использовать их
                   в качестве входных для выполнения утилиты cut. Поэтому 
                   производится отождествление стандартного ввода с файловым 
                   дескриптором второго канала, предназначенным для чтения. 
                   Для этого посредством СВ dup2() выполняется принудительное 
                   копирование дескриптора второго канала, предназначенного для 
                   чтения (запись с номером p1[0] = 5), в запись STDIN_FILENO = 0 из 
                   ТПДОФ. Поскольку дескриптор STDIN_FILENO = 0 перед вызовом dup2()
                   был открыт, то он предварительно закрывается: */
                dup2(p1[0], 0);
                /* Осуществлено перенаправление ввода. Вместо файла стандартного 
                   ввода, которым является клавиатура, установлен второй
                   межпроцессный канал, который открыт на чтение. Теперь данные, 
                   полученные от утилиты grep, которые содержатся во втором
                   межпроцессном канале, будут поступать из стандартного ввода 
                   в утилиту cut. 
                   СВ system() позволяет вызывающей программе выполнить произвольную 
                   консольную команду или вызвать другую программу, не выходя из 
                   контекста вызывающего процесса. СВ system() выполняет команду для 
                   утилиты "cut -d : -f 1", которая вырезает первое поле с именами 
                   файлов до разделителя двоеточие. В результате выполненного 
                   перенаправления ввода, утилита cut считает данные из второго 
                   канала p1[0] и выведет данные в стандартный вывод, т.е. на экран 
                   монитора: */
                system("cut -d : -f 1");
                /* Родительский процесс (т.е. вся программа) закрывается с помощью 
                   СВ _exit(0), который закрывает все открытые в процессе файлы. 
                   Код 0 означает правильное завершение процесса: */
                _exit(0);
            } // Ветка для родителя после успешного вызова второго СВ fork().
        } // Ветка для родителя после успешного вызова fork().
    } // При поступлении 3-х сигналов прерывания.
} // Функция обработчика сигнала.
