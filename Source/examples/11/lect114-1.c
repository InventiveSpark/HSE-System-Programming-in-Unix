// Код программы со встроенным обработчиком сигнала

/*
Задача:
Написать программу определения типа файла, указанного при запросе. 
Предусмотреть обработку сигнала прерывания от клавиатуры. При поступлении 
3-х сигналов прерывания вывести все файлы текущего каталога, написанные
на языке программирования С (или C++).
*/

// Заголовочные файлы:
#include <stdio.h>    // Для поддержания стандартного ввода-вывода
#include <unistd.h>   /* Для возможности мобильного переноса с одной вычислительной 
                         платформы на другую */
#include <stdlib.h>   // Для библиотечных функций memset() и exit()
#include <string.h>   /* Содержит прототипы функций работы со строками string(), 
                         strcasecmp(), strcat(), strcpy(), memset(), bzero() и т.д. */
#include <sys/wait.h> /* Для СВ wait(), позволяющего процессу-родителю дождаться 
                         момента, когда процесс-потомок выполнит работу и пришлет 
                         результаты своей работы */
#include <signal.h>   /* Для работы с сигнальной маской процесса и макросами, 
                         прототипами данных из функции sigaction() */

/* Глобальная переменная count, видимая всем функциям данной программы,
   выполняет роль счетчика сигналов: */
int count = 0;

/* Функция обработки сигнала handl() должна быть описана или объявлена перед 
   использованием СВ signal() или sigaction().
   Функция обработки сигнала запускает два процесса-потомка и открывает два 
   межпроцессных канала. Для выполнения задачи достаточно трех процессов:
   1. первый потомок выполняет утилиту file;
   2. второй потомок - grep;
   3. третий (родитель) - cut. */
void handl() // Описание функции обработчика сигнала
{ 
    /* Выделение памяти под переменные для хранения пользовательских файловых 
       дескрипторов двух межпроцессных каналов, открываемых СВ pipe(). Канал p
       будет использован для связи с первым процессом-потомком, канал p1 - для 
       связи со вторым потомком: */
    int p[2], p1[2];
    /* Счетчик сигналов прерывания увеличивается при поступлении каждого сигнала: */
    count++;
    /* При поступлении 3-х сигналов прерывания нужно вывести имена всех файлов 
       текущего каталога, написанных на языке программирования С или C++. 
       Эту информацию можно получить, реализовав конвейерное выполнение трех утилит 
       file (или find, которая работает медленнее), grep и cut:
       "file * | grep "C source" | cut -d : -f 1"
       В некоторых ОС утилита file может выводить "C program", тогда в качестве 
       аргумента утилиты grep вместо шаблона "C source" нужно использовать 
       "C program". */
    if (count == 3)
    {
        /* Первый межпроцессный канал будет использован для общения с первым 
           потомком, который будет создан для выполнения утилиты file.
           СВ pipe() создает первый межпроцессный канал и открывает два 
           пользовательских дескриптора файлов - p[0] с доступом к каналу на чтение
           и p[1] с доступом на запись, которые будут записаны в ТПДОФ (таблицу 
           пользовательских дескрипторов открытых файлов) процесса под новыми 
           номерами 3 и 4, соответственно: */
        pipe(p);
        /* После создания первого межпроцессного канала процесс с помощью СВ fork() 
           разделяется на две идентичные копии, которые продолжают выполняться как 
           два независимых процесса:
           1) Процесс-потомок получает от СВ fork() код ответа 0.
           2) Процесс-родитель - идентификатор, под которым запущен процесс-потомок. 
           В случае аварийного завершения СВ fork() вернет -1. 
           Создание первого процесса-потомка для выполнения утилиты file: */
        if (fork() == 0)
        {   /* Ветка для первого потомка (выполнит утилиту file) после успешного 
               вызова fork():
               Из ТПДОФ процесса-потомка удаляется запись с номером p[0] = 3, т.е. 
               закрывается доступ к межпроцессному каналу на чтение: */
            close(p[0]);
            /* Отождествление стандартного вывода с файловым дескриптором первого 
               канала, предназначенным для записи. Для этого посредством СВ dup2() 
               выполняется принудительное копирование дескриптора канала, 
               предназначенного для записи (запись с номером p[1] = 4), в запись 
               STDOUT_FILENO = 1 из ТПДОФ. Поскольку дескриптор STDOUT_FILENO = 1 
               перед вызовом dup2() был открыт, то он предварительно закрывается: */
            dup2(p[1], 1);
            /* Осуществлено перенаправление вывода. Вместо файла стандартного 
               вывода, которым является монитор, установлен первый межпроцессный 
               канал, который открыт на запись, поэтому результат выполнения любой 
               стандартной инструкции, функции или утилиты будет выводиться не 
               на экран монитора, а в первый межпроцессный канал. 
               СВ system() позволяет вызывающей программе выполнить произвольную 
               консольную команду или вызвать другую программу, не выходя из 
               контекста вызывающего процесса. СВ system() выполняет команду для 
               утилиты "file *", результат работы этой утилиты поступает в 
               первый межпроцессный канал, а не выводится на монитор: */
            system("file *");
            /* Первый процесс-потомок закрывается с помощью СВ _exit(0), который 
               закрывает все открытые в процессе файлы. Код 0 означает правильное 
               завершение процесса-потомка: */
            _exit(0);
        } // Ветка для первого потомка
        else
        { 
            /* Ветка для родителя после успешного вызова fork(). Родитель создаст 
               второго потомка, который выполнит утилиту grep, а затем сам родитель 
               выполнит утилиту cut.
               Вызвав СВ wait(), родитель приостанавливает свою работу и ждет 
               завершения первого процесса-потомка, выполнившего утилиту file.
               Аргумент 0 означает, что причина гибели процесса-потомка (например, 
               по СВ exit() или по сигналу) нам не интересна). Поскольку процесс-
               потомок к данному моменты был всего один, то возвращаемое значение 
               СВ wait() также неважно: */
            wait(0);
            /* Первый канал p в родительском процессе все еще существует, т.к. 
               межпроцессный канал уничтожатся только тогда, когда от него 
               отсоединяются все процессы и, хотя первый потомок завершен, но 
               родительский процесс все еще работает.
               Второй межпроцессный канал будет использован для общения со вторым
               потомком, который будет создан для выполнения утилиты grep.
               После завершения процесса первого потомка, процесс-родитель с помощью
               СВ pipe() создает второй межпроцессный канал и открывает два 
               пользовательских дескриптора файлов - p1[0] с доступом к каналу на 
               чтение и p1[1] с доступом на запись, которые будут записаны в ТПДОФ 
               процесса под новыми номерами 5 и 6, соответственно: */
            pipe(p1);
            /* Сторона первого канала, открытая для записи, больше не нужна, т.к.
               результат работы первого потомка (результат выполнения утилиты file) 
               уже хранится в файле канала с номером пользовательского дескриптора 
               p[0], открытым на чтение.
               Из ТПДОФ процесса-родителя удаляется запись с номером p[1] = 4, т.е. 
               закрывается доступ на запись к первому межпроцессному каналу, 
               использованному для общения с первым потомком: */
            close(p[1]);
            /* После создания второго межпроцессного канала процесс с помощью СВ fork() 
               разделяется на две идентичные копии, которые продолжают выполняться как 
               два независимых процесса:
               1) Процесс-потомок получает от СВ fork() код ответа 0.
               2) Процесс-родитель - идентификатор, под которым запущен процесс-потомок. 
               В случае аварийного завершения СВ fork() вернет -1. 
               Создание второго процесса-потомка для выполнения утилиты grep: */
            if (fork() == 0)
            {   /* Ветка для второго потомка (выполнит утилиту grep) после успешного 
                   вызова fork(): 
                   Из ТПДОФ второго потомка удаляется запись с номером p1[0] = 5, 
                   т.е. закрывается доступ ко второму межпроцессному каналу 
                   на чтение: */
                close(p1[0]);
                /* Отождествление стандартного вывода с файловым дескриптором второго 
                   канала, предназначенным для записи. Для этого посредством СВ dup2() 
                   выполняется принудительное копирование дескриптора канала, 
                   предназначенного для записи (запись с номером p1[1] = 6), в запись 
                   STDOUT_FILENO = 1 из ТПДОФ. Поскольку дескриптор STDOUT_FILENO = 1 
                   перед вызовом dup2() был открыт, то он предварительно закрывается: */
                dup2(p1[1], 1);
                /* Осуществлено перенаправление вывода. Вместо файла стандартного 
                   вывода, которым является монитор, установлен второй межпроцессный 
                   канал, который открыт на запись, поэтому результат выполнения любой 
                   стандартной инструкции, функции или утилиты будет выводиться не 
                   на экран монитора, а во второй межпроцессный канал.
                   Второй потомок должен считать данные от утилиты file и 
                   использовать их в качестве входных для выполнения утилиты grep.
                   Поэтому производится отождествление стандартного ввода с файловым 
                   дескриптором первого канала, предназначенным для чтения. 
                   Для этого посредством СВ dup2() выполняется принудительное 
                   копирование дескриптора первого канала, предназначенного для 
                   чтения (запись с номером p[0] = 3), в запись STDIN_FILENO = 0 из 
                   ТПДОФ. Поскольку дескриптор STDIN_FILENO = 0 перед вызовом dup2()
                   был открыт, то он предварительно закрывается: */
                dup2(p[0], 0);
                /* Осуществлено перенаправление ввода. Вместо файла стандартного 
                   ввода, которым является клавиатура, установлен первый 
                   межпроцессный канал, который открыт на чтение. Теперь данные, 
                   полученные от утилиты file, которые содержатся в первом 
                   межпроцессном канале, будут поступать из стандартного ввода 
                   в утилиту grep. 
                   В результате выполненных перенаправлений ввода-вывода, утилита 
                   grep считает данные из первого канала p[0] и выведет данные во 
                   второй канал p1[1].
                   СВ system() позволяет вызывающей программе выполнить произвольную 
                   консольную команду или вызвать другую программу, не выходя из 
                   контекста вызывающего процесса. СВ system() выполняет команду для 
                   утилиты "grep "C source"", результат работы этой утилиты поступает
                   во второй межпроцессный канал, а не выводится на монитор: */
                system("grep \"C source\"");
                /* Шаблон "C source" для утилиты grep состоит из двух слов. Шаблон, 
                   состоящий из двух слов и более необходимо обрамлять кавычками. 
                   Левый слеш используется для экранирования символа двойных 
                   кавычек, чтобы внутри одних кавычек сохранились вторые, вложенные
                   кавычки.
                   Второй процесс-потомок закрывается с помощью СВ _exit(1), который 
                   закрывает все открытые в процессе файлы. Код 1 означает 
                   правильное завершение процесса-потомка: */
                _exit(1);
            }
            else
            {   
                /* Ветка для родителя после успешного вызова второго СВ fork(). 
                   Продолжение кода родительского процесса, в котором он выполнит
                   утилиту cut. */
                /* Вызвав СВ wait(), родитель приостанавливает свою работу и ждет 
                   завершения второго процесса-потомка, выполнившего утилиту grep.
                   Аргумент 0 означает, что причина гибели процесса-потомка 
                   (например, по СВ exit() или по сигналу) нам не интересна). 
                   Поскольку первый процесс-потомок к данному моменты был уже 
                   завершен и остался только второй потомок, то возвращаемое 
                   значение СВ wait() также неважно: */
                wait(0);
                /* К данному моменту завершились оба процесса-потомка.
                   Из ТПДОФ родительского процесса удаляется запись с номером 
                   p1[1] = 6, т.е. закрывается доступ на запись ко второму 
                   межпроцессному каналу, использованному для общения со вторым 
                   потомком: */
                close(p1[1]);
                /* Родитель должен считать данные от утилиты grep и использовать их
                   в качестве входных для выполнения утилиты cut. Поэтому 
                   производится отождествление стандартного ввода с файловым 
                   дескриптором второго канала, предназначенным для чтения. 
                   Для этого посредством СВ dup2() выполняется принудительное 
                   копирование дескриптора второго канала, предназначенного для 
                   чтения (запись с номером p1[0] = 5), в запись STDIN_FILENO = 0 из 
                   ТПДОФ. Поскольку дескриптор STDIN_FILENO = 0 перед вызовом dup2()
                   был открыт, то он предварительно закрывается: */
                dup2(p1[0], 0);
                /* Осуществлено перенаправление ввода. Вместо файла стандартного 
                   ввода, которым является клавиатура, установлен второй
                   межпроцессный канал, который открыт на чтение. Теперь данные, 
                   полученные от утилиты grep, которые содержатся во втором
                   межпроцессном канале, будут поступать из стандартного ввода 
                   в утилиту cut. 
                   СВ system() позволяет вызывающей программе выполнить произвольную 
                   консольную команду или вызвать другую программу, не выходя из 
                   контекста вызывающего процесса. СВ system() выполняет команду для 
                   утилиты "cut -d : -f 1", которая вырезает первое поле с именами 
                   файлов до разделителя двоеточие. В результате выполненного 
                   перенаправления ввода, утилита cut считает данные из второго 
                   канала p1[0] и выведет данные в стандартный вывод, т.е. на экран 
                   монитора: */
                system("cut -d : -f 1");
                /* Родительский процесс (т.е. вся программа) закрывается с помощью 
                   СВ _exit(0), который закрывает все открытые в процессе файлы. 
                   Код 0 означает правильное завершение процесса: */
                _exit(0);
            } // Ветка для родителя после успешного вызова второго СВ fork().
        } // Ветка для родителя после успешного вызова fork().
    } // При поступлении 3-х сигналов прерывания.
} // Функция обработчика сигнала.

void main()
{
    // Выделение памяти под переменные:
    // int fd; // Для хранения пользовательского файлового дескриптора -  
               // не используется в программе.
    int p[2];  /* Для хранения пользовательских файловых дескрипторов межпроцессного 
                  канала, открываемого СВ pipe(). */

    /* Максимальная длина имени файла в UNIX-подобных ОС - 256 байт, включая 
       завершающий нулевой символ, который показывает конец имени. Выделение памяти 
       под символьные массивы для хранения имени файла name и буфера ввода-вывода 
       buf: */
    char name[256], buf[80];

    /* Поскольку могут быть предоставлены грязные страницы памяти, то прежде, чем
       использовать выделенную память, желательно ее очистить с помощью функции
       memset() или bzero(), занося нулевые значения в область памяти: */
    memset(name, 0, 256);
    memset(buf, 0, 80);

    /* Настройка обработчика сигнала: */
    /* Выделение памяти под объект типа struct sigaction, который содержит 3 поля.
       В объекте prer будет указан новый метод обработки сигнала: */
    struct sigaction prer;
    /* Задаются поля структуры struct sigaction:
       В поле sa_handler указывается имя (адрес) функции обработки сигнала, 
       описанной в начале программы */
    prer.sa_handler = handl;
    /* Поле sa_flags = 0, т.е. предусматривается стандартная обработка сигнала,
       который будет указан в СВ sigaction(). */
    prer.sa_flags = 0;
    /* Сохранение текущей СМ. Первые 2 аргумента нулевые, т.е. СМ текущего 
       процесса не будет изменяться, а будет записана в переменную prer.sa_mask.
       Поскольку при создании процесс-потомок наследует СМ своего родителя, то 
       весь перечень сигналов, которые поддерживаются ОС, отражен в СМ процесса,
       и ОС должна на него адекватно реагировать. */
    sigprocmask(0, 0, &prer.sa_mask);
    /* После того, как заполнены все три поля нового метода обработки сигнала 
       prer, исполняется СВ sigaction(), первым аргументом которого является 
       SIGINT (код 2) - сигнал прерывания < Ctrl+C > с терминала, по умолчанию 
       вызывающий завершение процесса.
       Вторым аргументом является prer - новый метод обработки сигнала.
       Третий аргумент 0 означает, что старый метод обработки сигнала не будет 
       сохранен, т.е. он не будет использоваться в дальнейшем.
       Поле prer.sa_mask определяет набор сигналов, которые будут добавлены к СМ
       процесса перед вызовом функции-обработчика prer.sa_handler = handl(). Перед
       возвратом из обработчика сигнала СМ будет автоматически восстановлена в 
       прежнее состояние. Таким способом можно блокировать определенные сигналы 
       на время работы функции-обработчика.
       Перед доставкой сигнала, когда вызывается функция-обработчик, сам сигнал 
       также включается в СМ; тем самым на время выполнения обработчика 
       блокируется доставка того же самого сигнала. Такой подход гарантирует 
       то, что во время обработки последующее поступление определенных сигналов 
       будет приостановлено до завершения вызова. */    
    sigaction(SIGINT, &prer, 0); 
    /* СВ sigaction() описан в начале программы, поэтому, если в дальнейшем поступит
       сигнал SIGINT, то программа всегда на него отреагирует: любое нажатие 
       < Ctrl+C > на клавиатуре вызовет функцию обработки сигнала handl(), которая 
       при каждом прерывании будет увеличивать счетчик сигналов, а при поступлении 
       3-х сигналов прерывания выведет все файлы текущего каталога, написанные на 
       языке программирования С или C++ и завершит выполнение программы. */

    /* Тело основной программы */
    /* Для повторения запроса на ввод от пользователя в случаях, когда предыдущие 
       введенные пользователем значения не прошли проверку, а также когда получен
       сигнал во время ввода (пользователь ввел часть информации, но вдруг поступил
       сигнал), можно было бы применить библиотечные функции безусловного переход 
       sigsetjmp() и siglongjmp(). Однако в данном случае выбран бесконечный цикл, 
       ждущий ввода имени существующего файла. Если во время ввода поступит сигнал, 
       то бесконечный цикл обеспечит повторение запроса на ввод от пользователя. 
       Также, пока не будет введено имя существующего файла, запрос на ввод будет 
       повторяться снова и снова: */
    while (1)
    {
        printf("Введите имя файла: ");
        // Функция scanf() считывает с клавиатуры цепочку символов до пробела.
        scanf("%s", name); // Ввод имени файла, не содержащего пробелы
        /* Альтернатива 1:
           Если в именах файла предполагается использовать пробелы, то функцию 
           scanf() можно заменить на СВ read(), который прочтет цепочку заданной 
           длины из любых символов:
           Сброс всех буферов для того, чтобы запрос на ввод имени файла, выведенный
           через функцию printf(), успел появиться до чтения имени файла через 
           СВ read(): */
        // fflush(NULL);
        // read(0, name, 256); // Ввод имени файла, содержащего пробелы
        /* Однако, если пользователь введет слишком длинную цепочку символов, 
           оказавшихся неверным именем файла, то в следующей итерации СВ read() 
           продолжит считывать оставшиеся символы как новый ввод пользователя. 
           Это делает использование этой функции неудобным. */
        /* Альтернативы 2 и 3:
           Если в именах файла предполагается использовать пробелы, то удобнее
           применить функцию gets(), считывающую строку из любых символов из 
           стандартного ввода до символа перевода строки '\n' (или до конца файла) 
           и записывающую ее в name: */
        // gets(name); // Ввод имени файла, содержащего пробелы
        /* Однако функция gets() не позволяет определить размер приемного буфера 
           name, поэтому использовать ее не следует. Если входная строка окажется
           длиннее буфера, то это приведет к его переполнению и порче данных, 
           которые находятся в памяти сразу после буфера. 
           Поэтому в данном случае целесообразнее использовать функцию fgets(): */
        // fgets(name, 256, stdin); // Ввод имени файла, содержащего пробелы 

        /* Посредством СВ access() проверяется, существует ли данный файл в текущей
           директории. Константа F_OK для СВ access() означает проверку на то, 
           существует ли файл? Для того, чтобы проверить, разрешен ли к файлу доступ
           на чтение, в CB access() нужно задать константу R_OK. 
           Если введено корректное имя файла и этот файл существует, */
        if (!access(name, F_OK))
            // то бесконечный цикл прерывается
            break;
        /* ...В противном случае файл не существует, тогда бесконечный цикл 
           продолжится, и запрос на ввод имени файла отправится снова.
           Если прерывание поступит во время ввода внутри этого цикла, то корректное
           имя файла не будет сформировано и снова произойдет возврат к запросу на 
           ввод имени файла. */
    } // Бесконечный цикл while(1)

    /* После ввода имени существующего файла СВ pipe() создает межпроцессный канал и 
       открывает два пользовательских дескриптора файлов - p[0] с доступом к каналу 
       на чтение и p[1] с доступом на запись, которые будут записаны в ТПДОФ 
       (таблицу пользовательских дескрипторов открытых файлов) процесса под новыми 
       номерами 3 и 4, соответственно: */
    pipe(p);
    /* После создания межпроцессного канала процесс с помощью СВ fork() разделяется 
       на две идентичные копии, которые продолжают выполняться как два независимых 
       процесса:
       1) Процесс-потомок получает от СВ fork() код ответа 0.
       2) Процесс-родитель - идентификатор, под которым запущен процесс-потомок. 
       В случае аварийного завершения СВ fork() вернет -1. */
    if (fork() == 0)
    {   /* Ветка для потомка после успешного вызова fork():
           Из ТПДОФ процесса-потомка удаляется запись с номером p[0] = 3, т.е. 
           закрывается доступ к межпроцессному каналу на чтение: */
        close(p[0]);
        /* Теперь потомок может только передавать информацию родителю...
           Закрытие дескриптора файла стандартного вывода STDOUT_FILENO = 1 
           (из ТПДОФ процесса-потомка удаляется запись с номером 1): */
        close(1);
        /* Отождествление стандартного вывода с файловым дескриптором канала, 
           предназначенным для записи. Для этого посредством СВ dup() выполняется 
           копирование дескриптора канала, предназначенного для записи (запись с 
           номером p[1] = 4), в первую (наименьшую) свободную запись в ТПДОФ 
           процесса (начиная от 0), т.е. в STDOUT_FILENO = 1, поскольку 
           STDIN_FILENO = 0 занят, а дескриптор файла стандартного вывода с номером
           1 был предварительно закрыт. */
        dup(p[1]);
        /* Осуществлено перенаправление вывода. Вместо файла стандартного вывода, 
           которым является монитор, установлен межпроцессный канал, который открыт 
           на запись, поэтому результат выполнения любой стандартной инструкции, 
           функции или утилиты будет выводиться не на экран монитора, а в 
           межпроцессный канал. 

           Выполнение утилиты ls с ключом -la, которая выводит список с подробной 
           информацией обо всех файлах (владелец, группа, права доступа, время 
           последнего обновления, размер и др.) текущего каталога, включая те файлы, 
           имена которых начинаются с точки (скрытые). Результат выполнения этой 
           инструкции вместо монитора будет выведен в межпроцессный канал.
           Утилита ls выполняется с помощью СВ execl(), аргументы которому задаются 
           в виде списка переменной длины, который должен заканчиваться значением 
           NULL, чтобы СВ execl() смог определить, какой именно аргумент является 
           последним. Первый аргумент СВ execl() - это полное имя программы ls, 
           которая находится в папке bin, затем идет нулевой внешний аргумент 
           (собственно, само имя программы ls), затем идут флаги -la и -d команды 
           ls, затем в качестве второго внешнего аргумента используется имя файла, 
           которое ввел пользователь. */
        execl("/bin/ls", "ls", "-la", "-d", name, NULL);
        /* СВ execl() убивает процесс, в рамках которого он был запущен, т.е. 
           вызывает новую программу вместо уже выполняющейся без возврата в 
           вызывающую программу. Выполнив новый процесс "ls -la -d ИМЯФАЙЛА", он 
           запишет результат его выполнения в межпроцессный канал вместо монитора. */
    }
    else
    {   /* Ветка для родителя после успешного вызова fork(): */
        /* Родитель приостанавливает свою работу и ждет завершения процесса-потомка, 
           вызвав СВ wait(). Аргумент 0 означает, что причина гибели процесса-потомка
           (например, по СВ exit() или по сигналу) нам не интересна). Поскольку
           процесс-потомок был всего один, то возвращаемое значение СВ wait() также 
           неважно: */
        wait(0);
        /* После завершения процесса-потомка, из ТПДОФ процесса-родителя удаляется 
           запись с номером p[1] = 4, т.е. закрывается доступ к межпроцессному 
           каналу на запись: */
        close(p[1]);
        /* Теперь родитель может только читать информацию от потомка...
           Бесконечный цикл, обрабатывающий результаты работы процесса-потомка: */
        while (1)
        {   /* Считывание данных из межпроцессного канала в массив buf по 80 байтов.
               Если прочитан хотя бы один байт, то */
            if (read(p[0], buf, 80) != 0)
            {   /* считанные данные обрабатываются - определяется тип файла по первому
                   символу (первому байту) в массиве buf: */
                if (buf[0] == '-')
                    printf("файл - обычный\n");
                if (buf[0] == 'd')
                    printf("файл директория\n");
                if (buf[0] == 'p')
                    printf("файл канал\n");
                if (buf[0] == 'c')
                    printf("файл специальный байт-ориентированный\n");
                if (buf[0] == 'b')
                    printf("файл специальный блок-ориентированный\n");
                if (buf[0] == 's')
                    printf("файл гнездо\n");
                if (buf[0] == 'l')
                    printf("файл символьная ссылка\n");
                /* Очистка символьного массива buf с помощью функции memset() путем
                   занесения нулевых значений в область памяти: */
                memset(buf, 0, 80);
            }
            /* Когда СВ read() вернет 0, будет достигнут конец файла межпроцессного 
               канала p[0]: */
            else
                break;
            /* Завершается выполнение основной программы. Библиотечная функция 
               exit() сбрасывает буферы ввода-вывода и завершает процесс, закрывая 
               все открытые в процессе файлы; код 0 означает правильное завершение 
               процесса-родителя: */
            exit(0);
        } // Бесконечный цикл while(1)
    }
}
