// Код программы без перехвата сигнала

/*
Задача:
Написать программу определения типа файла, указанного при запросе. 
Предусмотреть обработку сигнала прерывания от клавиатуры. При поступлении 
3-х сигналов прерывания вывести все файлы текущего каталога, написанные
на языке программирования С (или C++).
*/

// Заголовочные файлы:
#include <stdio.h>    // Для поддержания стандартного ввода-вывода
#include <unistd.h>   /* Для возможности мобильного переноса с одной вычислительной 
                         платформы на другую */
#include <stdlib.h>   // Для библиотечных функций memset() и exit()
#include <string.h>   /* Содержит прототипы функций работы со строками string(), 
                         strcasecmp(), strcat(), strcpy(), memset(), bzero() и т.д. */
#include <sys/wait.h> /* Для СВ wait(), позволяющего процессу-родителю дождаться 
                         момента, когда процесс-потомок выполнит работу и пришлет 
                         результаты своей работы */

/* Глобальная переменная count, видимая всем функциям данной программы,
   выполняет роль счетчика сигналов: */
int count = 0;

void main()
{
    // Выделение памяти под переменные:
    // int fd; // Для хранения пользовательского файлового дескриптора -  
               // не используется в программе.
    int p[2];  /* Для хранения пользовательских файловых дескрипторов межпроцессного 
                  канала, открываемого СВ pipe(). */

    /* Максимальная длина имени файла в UNIX-подобных ОС - 256 байт, включая 
       завершающий нулевой символ, который показывает конец имени. Выделение памяти 
       под символьные массивы для хранения имени файла name и буфера ввода-вывода 
       buf: */
    char name[256], buf[80];

    /* Поскольку могут быть предоставлены грязные страницы памяти, то прежде, чем
       использовать выделенную память, желательно ее очистить с помощью функции
       memset() или bzero(), занося нулевые значения в область памяти: */
    memset(name, 0, 256);
    memset(buf, 0, 80);
    /* Для повторения запроса на ввод от пользователя в случаях, когда предыдущие 
       введенные пользователем значения не прошли проверку, а также когда получен
       сигнал во время ввода (пользователь ввел часть информации, но вдруг поступил
       сигнал), можно было бы применить библиотечные функции безусловного переход 
       sigsetjmp() и siglongjmp(). Однако в данном случае выбран бесконечный цикл, 
       ждущий ввода имени существующего файла. Если во время ввода поступит сигнал, 
       то бесконечный цикл обеспечит повторение запроса на ввод от пользователя. 
       Также, пока не будет введено имя существующего файла, запрос на ввод будет 
       повторяться снова и снова: */
    while (1)
    {
        printf("Введите имя файла: ");
        // Функция scanf() считывает с клавиатуры цепочку символов до пробела.
        scanf("%s", name); // Ввод имени файла, не содержащего пробелы
        /* Альтернатива 1:
           Если в именах файла предполагается использовать пробелы, то функцию 
           scanf() можно заменить на СВ read(), который прочтет цепочку заданной 
           длины из любых символов:
           Сброс всех буферов для того, чтобы запрос на ввод имени файла, выведенный
           через функцию printf(), успел появиться до чтения имени файла через 
           СВ read(): */
        // fflush(NULL);
        // read(0, name, 256); // Ввод имени файла, содержащего пробелы
        /* Однако, если пользователь введет слишком длинную цепочку символов, 
           оказавшихся неверным именем файла, то в следующей итерации СВ read() 
           продолжит считывать оставшиеся символы как новый ввод пользователя. 
           Это делает использование этой функции неудобным. */
        /* Альтернативы 2 и 3:
           Если в именах файла предполагается использовать пробелы, то удобнее
           применить функцию gets(), считывающую строку из любых символов из 
           стандартного ввода до символа перевода строки '\n' (или до конца файла) 
           и записывающую ее в name: */
        // gets(name); // Ввод имени файла, содержащего пробелы
        /* Однако функция gets() не позволяет определить размер приемного буфера 
           name, поэтому использовать ее не следует. Если входная строка окажется
           длиннее буфера, то это приведет к его переполнению и порче данных, 
           которые находятся в памяти сразу после буфера. 
           Поэтому в данном случае целесообразнее использовать функцию fgets(): */
        // fgets(name, 256, stdin); // Ввод имени файла, содержащего пробелы 

        /* Посредством СВ access() проверяется, существует ли данный файл в текущей
           директории. Константа F_OK для СВ access() означает проверку на то, 
           существует ли файл? Для того, чтобы проверить, разрешен ли к файлу доступ
           на чтение, в CB access() нужно задать константу R_OK. 
           Если введено корректное имя файла и этот файл существует, */
        if (!access(name, F_OK))
            // то бесконечный цикл прерывается
            break;
        /* ...В противном случае файл не существует, тогда бесконечный цикл 
           продолжится, и запрос на ввод имени файла отправится снова.
           Если прерывание поступит во время ввода внутри этого цикла, то корректное
           имя файла не будет сформировано и снова произойдет возврат к запросу на 
           ввод имени файла. */
    } // Бесконечный цикл while(1)

    /* После ввода имени существующего файла СВ pipe() создает межпроцессный канал и 
       открывает два пользовательских дескриптора файлов - p[0] с доступом к каналу 
       на чтение и p[1] с доступом на запись, которые будут записаны в ТПДОФ 
       (таблицу пользовательских дескрипторов открытых файлов) процесса под новыми 
       номерами 3 и 4, соответственно: */
    pipe(p);
    /* После создания межпроцессного канала процесс с помощью СВ fork() разделяется 
       на две идентичные копии, которые продолжают выполняться как два независимых 
       процесса:
       1) Процесс-потомок получает от СВ fork() код ответа 0.
       2) Процесс-родитель - идентификатор, под которым запущен процесс-потомок. 
       В случае аварийного завершения СВ fork() вернет -1. */
    if (fork() == 0)
    {   /* Ветка для потомка после успешного вызова fork():
           Из ТПДОФ процесса-потомка удаляется запись с номером p[0] = 3, т.е. 
           закрывается доступ к межпроцессному каналу на чтение: */
        close(p[0]);
        /* Теперь потомок может только передавать информацию родителю...
           Закрытие дескриптора файла стандартного вывода STDOUT_FILENO = 1 
           (из ТПДОФ процесса-потомка удаляется запись с номером 1): */
        close(1);
        /* Отождествление стандартного вывода с файловым дескриптором канала, 
           предназначенным для записи. Для этого посредством СВ dup() выполняется 
           копирование дескриптора канала, предназначенного для записи (запись с 
           номером p[1] = 4), в первую (наименьшую) свободную запись в ТПДОФ 
           процесса (начиная от 0), т.е. в STDOUT_FILENO = 1, поскольку 
           STDIN_FILENO = 0 занят, а дескриптор файла стандартного вывода с номером
           1 был предварительно закрыт. */
        dup(p[1]);
        /* Осуществлено перенаправление вывода. Вместо файла стандартного вывода, 
           которым является монитор, установлен межпроцессный канал, который открыт 
           на запись, поэтому результат выполнения любой стандартной инструкции, 
           функции или утилиты будет выводиться не на экран монитора, а в 
           межпроцессный канал. 

           Выполнение утилиты ls с ключом -la, которая выводит список с подробной 
           информацией обо всех файлах (владелец, группа, права доступа, время 
           последнего обновления, размер и др.) текущего каталога, включая те файлы, 
           имена которых начинаются с точки (скрытые). Результат выполнения этой 
           инструкции вместо монитора будет выведен в межпроцессный канал.
           Утилита ls выполняется с помощью СВ execl(), аргументы которому задаются 
           в виде списка переменной длины, который должен заканчиваться значением 
           NULL, чтобы СВ execl() смог определить, какой именно аргумент является 
           последним. Первый аргумент СВ execl() - это полное имя программы ls, 
           которая находится в папке bin, затем идет нулевой внешний аргумент 
           (собственно, само имя программы ls), затем идут флаги -la и -d команды 
           ls, затем в качестве второго внешнего аргумента используется имя файла, 
           которое ввел пользователь. */
        execl("/bin/ls", "ls", "-la", "-d", name, NULL);
        /* СВ execl() убивает процесс, в рамках которого он был запущен, т.е. 
           вызывает новую программу вместо уже выполняющейся без возврата в 
           вызывающую программу. Выполнив новый процесс "ls -la -d ИМЯФАЙЛА", он 
           запишет результат его выполнения в межпроцессный канал вместо монитора. */
    }
    else
    {   /* Ветка для родителя после успешного вызова fork(): */
        /* Родитель приостанавливает свою работу и ждет завершения процесса-потомка, 
           вызвав СВ wait(). Аргумент 0 означает, что причина гибели процесса-потомка
           (например, по СВ exit() или по сигналу) нам не интересна). Поскольку
           процесс-потомок был всего один, то возвращаемое значение СВ wait() также 
           неважно: */
        wait(0);
        /* После завершения процесса-потомка, из ТПДОФ процесса-родителя удаляется 
           запись с номером p[1] = 4, т.е. закрывается доступ к межпроцессному 
           каналу на запись: */
        close(p[1]);
        /* Теперь родитель может только читать информацию от потомка...
           Бесконечный цикл, обрабатывающий результаты работы процесса-потомка: */
        while (1)
        {   /* Считывание данных из межпроцессного канала в массив buf по 80 байтов.
               Если прочитан хотя бы один байт, то */
            if (read(p[0], buf, 80) != 0)
            {   /* считанные данные обрабатываются - определяется тип файла по первому
                   символу (первому байту) в массиве buf: */
                if (buf[0] == '-')
                    printf("файл - обычный\n");
                if (buf[0] == 'd')
                    printf("файл директория\n");
                if (buf[0] == 'p')
                    printf("файл канал\n");
                if (buf[0] == 'c')
                    printf("файл специальный байт-ориентированный\n");
                if (buf[0] == 'b')
                    printf("файл специальный блок-ориентированный\n");
                if (buf[0] == 's')
                    printf("файл гнездо\n");
                if (buf[0] == 'l')
                    printf("файл символьная ссылка\n");
                /* Очистка символьного массива buf с помощью функции memset() путем
                   занесения нулевых значений в область памяти: */
                memset(buf, 0, 80);
            }
            /* Когда СВ read() вернет 0, будет достигнут конец файла межпроцессного 
               канала p[0]: */
            else
                break;
            /* Завершается выполнение основной программы. Библиотечная функция 
               exit() сбрасывает буферы ввода-вывода и завершает процесс, закрывая 
               все открытые в процессе файлы; код 0 означает правильное завершение 
               процесса-родителя: */
            exit(0);
        } // Бесконечный цикл while(1)
    }
}
