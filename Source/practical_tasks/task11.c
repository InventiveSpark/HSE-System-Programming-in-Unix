/*
    ПРАКТИКА НА C:
    Напишите программный код по заданию ниже на языке программирования C.
    Загрузите .c файл для оценки.

    Задание:
    Написать программу поиска в файле, имя которого вводится по запросу
    неограниченное число раз, строки с заданным шаблоном. Полученную информацию через 
    область внешних аргументов переслать в параллельный процесс и в нем вывести её 
    в файл. Предусмотреть возможность неоднократного прерывания по сигналу < Ctrl+C >. 
    При поступлении более десяти сигналов прерывания окончить выполнение программы.
    
    Описание решения:
    Искомая подстрока задается глобальной константой substring.
    Имя файла вывода задается глобальной константой output_file.
    Имя файла name, в котором производится поиск, пользователь вводит в терминале 
    по запросу программы.
    Глобальная константа command_size задает размер символьного массива, в котором 
    формируются как внешние аргументы утилиты, выводящей результаты поиска в файл, 
    так и команда для утилиты, осуществляющей поиск.
    В UNIX-подобных ОС имеются ограничения на максимальную длину аргументов вызовов 
    семейства exec (см. Стивен Р.У., Раго С.А. UNIX. Профессиональное программирование. 
    3-е издание. - СПб.: Питер, 2018 г., стр. 77-81, 90, 311-312). 
    Если длина найденных в файле строк превысит это ограничение, то непосредственная 
    передача строк между двумя процессами через область внешних аргументов может привести 
    к проблемам. Чтобы избежать этих проблем и сделать передачу информации между 
    процессами лаконичной, выбран вариант, при котором через внешние аргументы передаются 
    не сами строки, а их номера.
    Для построчного вывода номеров строк файла, содержащих искомый текст, выбрана утилита 
    awk, позволяющая в рамках одной команды получить результат, идентичный конвейерному 
    выполнению двух утилит grep и cut:
        grep -n "text to find" "./name" |cut -f1 -d:
    В основном процессе СВ system() запускает команду поиска, результат выполнения 
    которой поступает в межпроцессный канал. Канал используется только в рамках одного 
    процесса для перенаправления ввода-вывода при запуске утилиты awk и обработки 
    результатов её работы.
    Для вывода в файл найденных строк выбрана утилита sed, т.к. ее лаконичный 
    (в сравнении с утилитой awk) синтаксис позволяет выводить строки, представленные 
    как отдельными номерами, так и непрерывными диапазонами. В некоторых случаях 
    этот подход позволяет значительно сократить количество и суммарную длину внешних 
    аргументов.
    Результаты работы утилиты awk, сохраненные в межпроцессном канале, анализируются, 
    и формируется лаконичная запись команды вывода искомых строк для утилиты sed.
    Основная идея обмена информацией между процессами через область внешних аргументов 
    описана в лекции 3.2 "Информационные связи между параллельными процессами", 
    3 мин. 51 сек. Следуя этой идее, с помощью СВ fork() основной процесс разделяется 
    на две идентичные копии, которые продолжают выполняться как два независимых процесса. 
    Процесс-потомок, используя файловый дескриптор стандартного вывода, открывает файл 
    output_file для вывода, создаёт массив указателей на внешние аргументы утилиты sed, 
    унаследованные от основного процесса через символьный массив command, и передает этот 
    массив указателей в СВ execv().
    Таким образом, результаты поиска подстроки через область внешних аргументов передаются 
    в параллельно выполняемую утилиту sed, вывод которой перенаправляется в целевой файл.
    Итоговый результат работы программы идентичен результату выполнения команды вида:
        grep "text to find" "./name" > search_results.txt
*/

// Заголовочные файлы:
#include <stdio.h>    /* Для поддержания стандартного ввода-вывода. Включает функции 
                         scanf(), printf(), fgets(), fputs() и др. Функции stdio 
                         наслаиваются поверх СВ ввода-вывода (open(), close(), read(), 
                         write() и т.д.). */
#include <unistd.h>   /* Для возможности мобильного переноса с одной вычислительной 
                         платформы на другую */
#include <stdlib.h>   // Для библиотечных функций exit() и abs() и СВ system()
#include <string.h>   /* Содержит прототипы функций работы со строками string(), 
                         strcasecmp(), strcat(), strcpy(), memset(), bzero() и т.д. */
#include <sys/wait.h> /* Для СВ wait(), позволяющего процессу-родителю дождаться момента, 
                         когда процесс-потомок выполнит работу и пришлет результаты своей 
                         работы */
#include <sys/stat.h> /* Для СВ stat(), позволяющего получить атрибуты индексного 
                         дескриптора файла */
#include <fcntl.h>    // Для управления файлами

//#define DEBUG       // Вывод отладочных сообщений

// Глобальные константы:
// Искомая подстрока:
static const char substring[] = "text to find";
// Имя файла вывода:
static const char output_file[] = "search_results.txt";
/* Размер символьного массива для формирования команды для утилиты awk и внешних
   аргументов для утилиты sed */
static const size_t command_size = 2000;
// Размер символьного буфера
static const size_t buf_size = 80;
/* Добавление static к переменной, объявленной вне блока, определяет её как внутреннюю,
   то есть такую, которую можно использовать только в файле, в котором она определена. */

/*
   Функция обработки сигнала handl() должна быть описана или
   объявлена перед использованием СВ signal() или sigaction()
*/
void handl()
{
    // Выделение памяти под переменные:
    // Статические переменные
    static int count = 0; // Счетчик сигналов прерывания

    /* Тело программы обработчика */
    /* Счетчик сигналов прерывания увеличивается при поступлении каждого сигнала,
       и на экран выводится сообщение: */
    ++count;
    fprintf(stderr, "\n\tСигнал SIGINT поступил %d раз%s\n", count, (2 <= count && count <= 4) ? "а" : "");
    // При поступлении более десяти сигналов прерывания завершается выполнение программы.
    if (count > 10)
    {
        /* Программа закрывается с помощью СВ _exit(0); код 0 означает
           правильное завершение процесса обработчика. */
        _exit(0);
    }
}

/*
   Функция с обработчиком ошибок (error handler) вызова dup2(), который создает дубликат 
   пользовательского дескриптора существующего файла и часто используется в программе.
   Функция возвращает новый дескриптор файла, а в случае ошибки выводит сообщение и 
   завершает работу программы.
*/
int dup2_eh(const int fd, const int fd2)
{
    // Выделение памяти под переменные:
    int result = dup2(fd, fd2);
    if (result == -1)
    {
        /* Обработка ошибки */
        fprintf(stderr, "\tОшибка создания дубликата дескриптора существующего файла\n");
        _exit(43);
        /* Код 43 означает завершение работы программы, вызванное ошибкой СВ dup2(). */
    }
    return result;
}

/*
   Функция с обработчиком ошибок (error handler) вызова close(), который закрывает 
   открытый файл и часто используется в программе.
   Функция возвращает 0 в случае успеха, а в случае ошибки выводит сообщение и завершает 
   работу программы.
*/
int close_eh(const int fd)
{
    // Выделение памяти под переменные:
    int result = close(fd);
    if (result == -1)
    {
        /* Обработка ошибки */
        fprintf(stderr, "\tОшибка закрытия файла\n");
        _exit(46);
        /* Код 46 означает завершение работы программы, вызванное ошибкой СВ close(). */
    }
    return result;
}

 /*
    Функция определяет окончания в словах (склонение или изменение по падежам), 
    относящихся к числовому значению аргумента arg.
 */
int inclination_by_number(int arg)
{
    // Выделение памяти под переменные:
    int n, result;
    n = abs(arg) % 100; // Для корректной работы необходимо абсолютное значение
    result = 2;
    if (n <= 4 || 20 <= n)
    {
        n = n % 10;
        if (n == 1)
        { 
            result = 0;
        }
        else if (2 <= n && n <= 4)
        {
            result = 1;
        }
    }
    return(result);
}

/*
   Функция формирования в массиве command внешних аргументов утилиты sed для вывода 
   нескольких строк, представленных как отдельными номерами (если start_of_group 
   и end_of_group равны), так и непрерывными диапазонами (от start_of_group 
   до end_of_group).
   Цепочка символов, разделенных пробелом, формирует аргументы, которые добавляются
   в символьный массив command. При успешном добавлении внешних аргументов 
   пополняется их количество command_args_count и обновляется размер символьного 
   массива current_command_size.
   Функция выводит сообщение об ошибке и завершает работу программы, если в массиве 
   command недостаточно места для пополнения его новыми аргументами.

   Ключи и команды утилиты sed:
   Ключ "-n" подавляет обычный вывод, оставляя только указанные строки;
   Ключ "-e" нужен для выполнения нескольких действий с данными;
   Команда "p" печатает определенные строки по их номеру или диапазону номеров. 
   Интервал обозначается через запятую включительно. Например, для вывода строк файла 
   somefile.txt со второй по четвертую, а также седьмой строки:
   sed -n -e 2,4p -e 7p somefile.txt
*/
void add_group(const int start_of_group, const int end_of_group, char *command, size_t *current_command_size, int *command_args_count)
{
    // Выделение памяти под переменные:
    /* Символьный массив-буфер для хранения результатов работы функции sprintf()
       при формировании внешних аргументов */
    char buf[buf_size];
    // Текущий размер буфера
    size_t current_buf_size;

    // Формирование внешних аргументов в буфере:
    if (start_of_group == end_of_group) // Отдельный номер
    {
        sprintf(buf, "-e %dp ", end_of_group);
    }
    else // if (start_of_group < end_of_group) Непрерывный диапазон
    {
        sprintf(buf, "-e %d,%dp ", start_of_group, end_of_group);
    }
    // Определение текущего размера буферного массива
    current_buf_size = strlen(buf);
    // Если возникла угроза переполнения целевого массива command,
    if (command_size < *current_command_size + current_buf_size)
    {  
        /* то функция сообщает об ошибке, и программа закрывается с помощью СВ _exit(66);
           код 66 означает завершение работы программы, вызванное ошибкой переполнения 
           символьного массива command: */
        fprintf(stderr, "\tПереполнение символьного массива для формирования команд!\n");
        _exit(66);
    }    
    // Конкатенация (объединение) строк
    strcat(command, buf);
    // Обновление текущего размера символьного массива command
    *current_command_size += current_buf_size;
    // Пополнение количества аргументов утилиты sed
    *command_args_count += 2; /* ключ "-e" и команда "p" с номером или диапазоном номеров 
                                 строк */
}

int main()
{
    // Константы:
    /* Максимальная длина имени файла в UNIX-подобных ОС - 256 байт, включая завершающий 
       нулевой символ, который показывает конец имени. */
    const size_t maxfilename_size = 256;
    /* Варианты окончания слова "строка" в зависимости от числового значения. */
    const char *ending[] = {"а", "и", ""}; 
    // Выделение памяти под переменные:
    int fd;               /* Для хранения пользовательского файлового дескриптора файла 
                             вывода */
    int fd_std_out_copy;  /* Для хранения копии пользовательского дескриптора 
                             стандартного вывода */
    int p[2];             /* Для хранения пользовательских файловых дескрипторов 
                             межпроцессного канала, открываемого СВ pipe(). Канал будет 
                             использован в рамках одного процесса. */
    size_t filename_size; // Для хранения длины имени файла, вводимого пользователем
    /* Выделение памяти под символьные массивы для хранения имени файла name, буфера
       ввода-вывода buf и command - для формирования выполняемых команд, содержащих 
       внешние аргументы: */
    char name[maxfilename_size], buf[buf_size], command[command_size];
    int dig_buf;                      /* Для временного хранения прочитанных числовых 
                                         значений */
    int start_of_group, end_of_group; /* Для хранения начального и конечного номеров 
                                         непрерывной группы строк */
    int found_strings = 0;            // Для хранения количества найденных строк
    int inclination;                  // Для хранения склонения слова "строка"
    int command_args_count;           /* Для хранения количества сформированных внешних  
                                         аргументов командной строки для утилиты sed */
    size_t current_command_size;      /* Для хранения текущего размера символьного 
                                         массива command, в котором формируется командная 
                                         строка (добавляются аргументы) для утилиты sed */
    int status;                       // Для хранения кода завершения процесса потомка

    /* Настройка обработчика сигнала: */

    /* Выделение памяти под объект типа struct sigaction, который содержит 3 поля. 
       В объекте prer будет указан новый метод обработки сигнала: */
    struct sigaction prer;
    /* Задаются поля структуры struct sigaction:
       В поле sa_handler указывается имя (адрес) функции обработки сигнала, описанной 
       в начале программы */
    prer.sa_handler = handl;
    /* Поле sa_flags = 0, т.е. предусматривается стандартная обработка сигнала, который 
       будет указан в СВ sigaction(). */
    prer.sa_flags = 0;
    /* Сохранение текущей сигнальной маски. Первые 2 аргумента нулевые, т.е. сигнальная
       маска текущего процесса не будет изменяться, а будет записана в переменную 
       prer.sa_mask. */
    if (sigprocmask(0, 0, &prer.sa_mask) == -1)
    {
        /* Обработка ошибки */
        fprintf(stderr, "\tОшибка вызова sigprocmask\n");
        _exit(10);
        /* Код 10 означает завершение работы программы, вызванное ошибкой при сохранении 
           текущей маски сигналов через СВ sigprocmask(). */
    }
    /* 
       Поскольку при создании процесс-потомок наследует сигнальную маску своего
       родителя, то весь перечень сигналов, которые поддерживаются ОС, отражен
       в сигнальной маске процесса, и ОС должна на него адекватно реагировать.
       После того, как заполнены все три поля нового метода обработки сигнала prer,
       исполняется СВ sigaction(), первым аргументом которого является
       SIGINT (код 2) - сигнал прерывания < Ctrl+C > с терминала, по умолчанию вызывающий
       завершение процесса.
       Вторым аргументом является prer - новый метод обработки сигнала.
       Третий аргумент 0 означает, что старый метод обработки сигнала не будет сохранен,
       т.е. он не будет использоваться в дальнейшем.
       Поле prer.sa_mask определяет набор сигналов, которые будут добавлены к маске
       сигналов процесса перед вызовом функции-обработчика. Перед возвратом из 
       обработчика сигнала маска сигналов будет автоматически восстановлена в прежнее 
       состояние. Таким способом можно блокировать определенные сигналы на время работы 
       функции-обработчика.
       Перед доставкой сигнала, когда вызывается функция-обработчик, сам сигнал также
       включается в маску сигналов; тем самым на время выполнения обработчика 
       блокируется доставка того же самого сигнала. Такой подход гарантирует то, что во 
       время обработки последующее поступление определенных сигналов будет 
       приостановлено до завершения вызова.
    */
    if (sigaction(SIGINT, &prer, 0) == -1)
    {
        /* Обработка ошибки */
        fprintf(stderr, "\tОшибка вызова sigaction\n");
        _exit(15);
        // Код 15 означает завершение работы программы, вызванное ошибкой СВ sigaction().
    }
    /* СВ sigaction() описан в начале программы, поэтому, если в дальнейшем поступит
       сигнал SIGINT, то программа всегда на него отреагирует: любое нажатие < Ctrl+C >
       на клавиатуре вызовет функцию обработки сигнала handl(), который при каждом
       прерывании будет увеличивать счетчик сигналов, а при поступлении более десяти
       сигналов прерывания завершит выполнение программы. */

    /* Тело основной программы: */

#ifdef DEBUG
    fprintf(stderr, "\tDEBUG mode is ON\n");
#endif

    /* Бесконечный цикл, ждущий ввода имени существующего обычного файла, 
       доступного для чтения: */
    while (1)
    {
        printf("Введите имя файла: "); // Запрос на ввод имени файла
        /* Поскольку во время ожидания ввода пользователя может поступить сигнал 
           прерывания, а также могут быть предоставлены грязные страницы памяти, то 
           прежде чем использовать выделенную память, желательно ее очистить с помощью 
           функции memset() или bzero(), занося нулевые значения в область памяти: */
        memset(name, 0, sizeof(name) / sizeof(name[0]));
      
        fgets(name, maxfilename_size, stdin); // Ввод имени файла, содержащего пробелы

        // Определение длины введенного имени файла:
        filename_size = strlen(name);
        /* В отличии от функции gets(), функция fgets() и СВ read(), сохраняют в буфере 
           символ перевода строки '\n', поэтому результирующая прочитанная строка у них 
           будет на один символ длиннее, чем у gets. 
           Для корректной работы с файлом, из конца строки, содержащей его имя, нужно
           удалить лишний символ перевода строки, добавленный fgets() или read(): */
        if (filename_size > 0 && name[filename_size - 1] == '\n')
        {
            name[--filename_size] = '\0';
        }

        /* Если длина введенной пользователем строки с предполагаемым именем файла 
           содержит хотя бы один символ, то выполняется ее проверка.
           Если во время ожидания ввода пользователя поступит сигнал прерывания, то имя
           файла name не будет прочитано, произойдет повторный запрос на ввод. */
        if (filename_size > 0)
        {
            /* Проверка на недопустимые символы в имени файла не требуется, т.к.
               только два символа не могут встречаться в именах файлов - прямой слеш '/'
               и нулевой символ '\0'. Нулевой символ был отброшен при чтении имени файла,
               а прямой слеш в имени файла будет проверяться при исключении директорий.
               Посредством СВ access() проверяется, существует ли данный файл и 
               разрешен ли к нему доступ на чтение. */
            if (access(name, F_OK) == -1)
            {
                printf("\tФайл '%s' не существует!\n", name);
            }
            else if (access(name, R_OK) == -1)
            {
                printf("\tДоступ к файлу '%s' запрещен!\n", name);
            }
            else // Если файл существует и к нему разрешен доступ на чтение:
            {
                struct stat statbuf;
                /* Примечание: Когда в СВ stat() передается имя символической ссылки, он 
                   возвращает сведения о файле, на который ссылка ссылается, а не о самой 
                   символической ссылке.
                   Заполнение структуры типа stat, содержащей атрибуты индексного 
                   дескриптора файла с заданным именем name: */
                if (stat(name, &statbuf) == -1)
                {
                    printf("\tОшибка вызова stat\n");
                    _exit(20);
                    /* Код 20 означает завершение работы программы, вызванное ошибкой 
                       СВ stat(). */
                }
                if (S_ISDIR(statbuf.st_mode) == 1)       // Исключение директорий:
                {
                    printf("\tФайл '%s' является директорией!\n", name);
                }
                else if (S_ISFIFO(statbuf.st_mode) == 1) // Исключение каналов:
                {
                    printf("\tФайл '%s' является каналом (именованным или неименованным)!\n", name);
                }
                else if (S_ISSOCK(statbuf.st_mode) == 1) // Исключение гнезд:
                {
                    printf("\tФайл '%s' является гнездом (socket)!\n", name);
                }
                                                         // Исключение специальных файлов:
                else if (S_ISBLK(statbuf.st_mode) == 1)
                {
                    printf("\t'%s' является специальным файлом блочного устройства!\n", name);
                }
                else if (S_ISCHR(statbuf.st_mode) == 1)
                {
                    printf("\t'%s' является специальным файлом символьного устройства (байт-ориентированным)!\n", name);
                }
                else
                {
                  /* Если введено корректное имя файла и этот файл существует, а также 
                     является обычным файлом или символической ссылкой на обычный файл, 
                     то бесконечный цикл прерывается: */
                    printf("\tПоиск подстроки '%s' в файле '%s'\n", substring, name);
                    break;
                }
            }
            /* ...В противном случае, бесконечный цикл продолжается, запрос на ввод имени 
               файла отправляется снова. */
        }         
    } // Бесконечный цикл while(1)

    /* После ввода имени существующего обычного файла, доступного для чтения: */
    
    /* В массиве command формируется команда утилите awk для построчного вывода номеров 
       строк файла name, содержащих искомый текст substring. Например, для 
       substring = "text to find":
       awk '/text to find/ {print FNR}' "./name"
       Результат работы awk аналогичен конвейерному выполнению двух утилит grep и cut:
       grep -n "text to find" "./name" |cut -f1 -d:
    */
    sprintf(command, "awk '/%s/ {print FNR}' '%s'", substring, name);

#ifdef DEBUG
    fprintf(stderr, "\tПервая команда: %s\n", command);
#endif

    /* Перенаправление вывода перед запуском утилиты awk: */

    /* Для каждого процесса изначально открыты три основных файла потоков, которые могут
       использовать программы, они идентифицируются по номеру пользовательского 
       дескриптора файла:
       STDIN или 0  -  этот файл связан с клавиатурой, и большинство команд получают 
                       данные для работы отсюда;
       STDOUT или 1 -  это стандартный вывод, сюда программа отправляет все результаты 
                       своей работы. Он связан с экраном или, если быть точным, 
                       с терминалом, в котором выполняется программа;
       STDERR или 2 -  все сообщения об ошибках выводятся в этот файл.

       СВ pipe() создает межпроцессный канал и открывает два пользовательских дескриптора
       файлов - p[0] с доступом к каналу на чтение и p[1] с доступом на запись, которые
       будут записаны в ТПДОФ (таблицу пользовательских дескрипторов открытых файлов) 
       процесса под новыми номерами 3 и 4, соответственно: */
    if (pipe(p) == -1)
    {
        fprintf(stderr, "\tОшибка создания межпроцессного канала\n");
        _exit(30);
        // Код 30 означает завершение работы программы, вызванное ошибкой СВ pipe().
    }
    /* Согласно условиям задачи, переслать информацию другому процессу можно лишь через
       область внешних аргументов, поэтому межпроцессный канал будет использован в рамках
       одного процесса для перенаправления ввода-вывода при запуске утилиты awk 
       и обработки результатов её работы.
       Фактически через канал процесс осуществляет пересылку данных самому себе. */
    if ((fd_std_out_copy = dup(STDOUT_FILENO))==-1) /* Создание копии пользовательского 
                                                       дескриптора стандартного вывода. */
    {
        /* Обработка ошибки */
        fprintf(stderr, "\tОшибка создания дубликата дескриптора существующего файла\n");
        _exit(40);
        /* Код 40 означает завершение работы программы, вызванное ошибкой СВ dup(). */
    }
    dup2_eh(p[1], STDOUT_FILENO);                   /* Отождествление стандартного вывода 
                                                       STDOUT_FILENO = 1 с файловым 
                                                       дескриптором канала, 
                                                       предназначенным для записи. */
    close_eh(p[1]);                                 /* Закрытие файлового дескриптора 
                                                       канала, предназначенного 
                                                       для записи. */
    /* Осуществлено перенаправление вывода. Вместо файла стандартного вывода, которым
       является монитор, установлен межпроцессный канал, который открыт на запись,
       поэтому результат выполнения любой стандартной инструкции, функции или утилиты
       будет выводиться не на экран монитора, а в межпроцессный канал.

       СВ system() позволяет вызывающей программе выполнить произвольную консольную 
       команду или вызвать другую программу, не выходя из контекста вызывающего процесса.
       СВ system() выполняет команду, сформированную в массиве command для утилиты awk,
       результат работы этой утилиты поступает в межпроцессный канал, а не выводится 
       на монитор: */
    if (system(command) == -1)
    {
        fprintf(stderr, "\tОшибка вызова system\n");
        _exit(50);
        // Код 50 означает завершение работы программы, вызванное ошибкой СВ system().
    } 
    /* Для того, чтобы функция fgets() смогла затем корректно прочитать данные, 
       сформированные утилитой awk, добавляется завершающий символ перевода строки: */
    fputs("\n", stdout);    
    // Теперь данные, готовые к дальнейшей обработке, находятся в межпроцессном канале.
    
    /* Перенаправление ввода перед обработкой результатов работы утилиты awk: */
    
    close_eh(STDOUT_FILENO);     /* Закрытие файлового дескриптора канала, 
                                    предназначенного для записи. */
    dup2_eh(p[0], STDIN_FILENO); /* Отождествление стандартного ввода STDIN_FILENO = 0 
                                    с файловым дескриптором канала, предназначенным 
                                    для чтения. */
    close_eh(p[0]);              /* Закрытие файлового дескриптора канала, 
                                    предназначенного для чтения. */
    /* Осуществлено перенаправление ввода. Вместо файла стандартного ввода, которым 
       является клавиатура, установлен межпроцессный канал, который открыт на чтение. */

    /* Обработка номеров строк, выданных утилитой awk и формирование команды для вывода
       результатов поиска в файл: */
    
    /* Для вывода найденных строк из файла name по их номерам (и диапазонам номеров)
       выбрана утилита sed, т.к. ее синтаксис для данной подзачачи лаконичнее в сравнении
       с утилитой awk. Это позволит сократить количество и суммарную длину внешних 
       аргументов.
       Ключи и команды утилиты sed были подробно описаны выше - в комментариях к функции 
       формирования внешних аргументов add_group().
    
       В межпроцессном канале построчно записаны числа, являющиеся номерами строк файла 
       name, содержащих искомый текст substring. Числа не повторяются и идут в 
       возрастающей последовательности. Для лаконичной записи команд вывода строк, 
       необходимо найти монотонно возрастающие последовательности (далее - группы) 
       максимальной длины, каждый последующий элемент которых больше предыдущего
       на единицу. Алгоритм поиска:
       1) Начинается просмотр новой группы (или всего списка чисел, если поиск начался
          только что). Первое число будет являться началом и концом новой непрерывной 
          группы (start_of_group и end_of_group).
       2) Продолжается просмотр. Если следующее число превышает end_of_group на единицу, 
          то число start_of_group будет действительным началом очередной непрерывной
          группы, а текущее становится новым концом этой группы (end_of_group).
       3) Продолжается просмотр с обновлением значения end_of_group (см. пункт 2). Если 
          очередное число превышает end_of_group более чем на 1 или, если достигнут 
          конец всего списка, то значения start_of_group и end_of_group сравниваются:
       3.1) Если они равны друг другу, то выводится одиночное значение.
       3.2) Если они различаются, то выводится диапазон найденной непрерывной группы.
       4) Если конец всего списка не достигнут, то повторяется пункт 1.
       
       По этому алгоритму в массиве command будут сформированы внешние аргументы утилиты 
       sed для вывода найденных строк, представленных как отдельными номерами, так и
       непрерывными диапазонами:
    */
    strcpy(command, "sed -n "); /* Ключ "-n" подавляет обычный вывод, оставляя только 
                                   указанные строки */
    // Инициируется переменная с количеством внешних аргументов утилиты sed:
    command_args_count = 2;     // Два аргумента - это "sed" и "-n"
    /* Текущий размер символьного массива command, в котором формируется команда 
       для утилиты sed: */
    current_command_size = strlen(command);
    /* Построчное чтение из межпроцессного канала результатов работы утилиты awk 
       и формирование команды для утилиты sed с подсчетом числа ее внешних агрументов: */
    while (fgets(buf, buf_size, stdin) != 0)
    {
        /* Построчная оцифровка данных (извлечение номеров строк в буфер dig_buf)
           из строк, выведенных утилитой awk: */
        if (sscanf(buf, "%d", &dig_buf) != 1) // Если достигнут конец всего списка чисел,
        {
            if (found_strings != 0) // и если найдена хотя бы одна строка,
            { 
                // то формирование команды для утилиты sed завершается,
                add_group(start_of_group, end_of_group, command, &current_command_size, &command_args_count);
                // пополняется количество внешних аргументов в команде для утилиты sed:
                command_args_count++; /* Учитывается имя файла, которое позже будет 
                                         добавлено к внешним аргументам. */
#ifdef DEBUG
                fprintf(stderr, "\tВторая команда из %d аргументов: %s'%s'\n", command_args_count, command, name);
#endif
            }
            else
            {
                // Если ни одной строки не найдено, массив command обнуляется:
                memset(command, 0, sizeof(command) / sizeof(command[0]));
            }
            break; // Выход из while после обработки всех данных из межпроцессного канала
        }
        // Если номер строки успешно прочитан,
        found_strings++; // то число найденных строк увеличивается.
        // Если в данных обнаружена ошибка:
        if (dig_buf <= 0)
        {
            /* Обработка ошибки */
            fprintf(stderr, "\tНомера найденных строк должны быть натуральными числами!\n");
            _exit(60);
            /* Код 60 означает завершение работы программы, вызванное ошибкой в данных, 
               выведенных утилитой awk. */
        }
        // Если просмотр всего списка чисел только начался,
        else if (found_strings == 1)
        {
           /* то первое число будет являться и началом, и концом первой непрерывной 
           группы: */
            start_of_group = end_of_group = dig_buf;
        }
        // Если в данных обнаружена ошибка:
        else if (dig_buf <= end_of_group)
        {
            /* Обработка ошибки */
            fprintf(stderr, "\tНомера найденных строк должны быть уникальными и идти в возрастающей последовательности!\n");
            _exit(63);
            /* Код 63 означает завершение работы программы, вызванное ошибкой в данных, 
               выведенных утилитой awk. */
        }
        // Если очередное число превышает предыдущее на единицу,
        else if (dig_buf == end_of_group + 1)
        {
            /* то число start_of_group будет действительным началом очередной непрерывной
               группы, а текущее становится новым концом этой группы: */
            end_of_group = dig_buf;
        }
        /* Если очередное число превышает предыдущее (end_of_group) более чем на единицу,
           то найденное одиночное значение или непрерывная группа записываются в качестве
           внешних аргументов для утилиты sed: */
        else
        {
            add_group(start_of_group, end_of_group, command, &current_command_size, &command_args_count);
            /* Текущее число будет являться и началом, и концом новой непрерывной 
               группы: */
            start_of_group = end_of_group = dig_buf;
        }
    } // while

    /* Восстановление пользовательского дескриптора стандартного вывода и удаление 
       межпроцессного канала после его использования в рамках одного процесса для 
       перенаправления ввода-вывода при запуске утилиты awk и обработки результатов
       её работы: */
    close_eh(STDIN_FILENO);                  /* После закрытия пользовательского 
                                                дескриптора канала, предназначенного для 
                                                чтения, межпроцессный канал будет удален,
                                                т.к. все процессы, связанные с FIFO 
                                                файлом межпроцессного канала, закрыли все
                                                свои ссылки на него. */
    dup2_eh(fd_std_out_copy, STDOUT_FILENO); /* Восстановление файлового дескриптора 
                                                стандартного вывода. */
    close_eh(fd_std_out_copy);               /* Закрытие копии файлового дескриптора
                                                стандартного вывода. */

    // Определение окончания слова "строка" в зависимости от количества найденных строк:
    inclination = inclination_by_number(found_strings);
    printf("\tНайден%s %d строк%s\n", (inclination == 0 ? "а" : "о"), found_strings, ending[inclination]);

    /* С помощью СВ fork() текущий процесс разделяется на две идентичные копии, которые 
       продолжают выполняться как два независимых процесса:
       1) Процесс-потомок получает от СВ fork() код ответа 0.
       2) Процесс-родитель - идентификатор, под которым запущен процесс-потомок. 
       В случае аварийного завершения СВ fork() вернет -1. */
    switch (fork())
    {
    case -1: // Если вызов fork() завершился неудачей:
        /* Обработка ошибки */
        fprintf(stderr, "\tОшибка вызова fork\n");
        /* Программа закрывается с помощью СВ _exit(70); код 70 означает завершение 
           работы программы, вызванное ошибкой при создании дубликата текущего процесса. */
        _exit(70);
        break;
    case 0: // Ветка для потомка после успешного вызова fork():               
        /* Процесс-потомок открывает для вывода файл output_file, используя файловый 
           дескриптор стандартного вывода.
           Для этого СВ creat() создает и открывает новый файл для записи с заданным 
           путевым именем output_file или, если файл уже существует, открывает файл 
           и усекает его до нулевой длины. Задаваемые права доступа: "rw-rw-rw-". 
           В качестве результата своей работы creat() возвращает дескриптор файла fd, 
           который будет использован последующими системными вызовами. */
        if ((fd = creat(output_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)
        {
            fprintf(stderr, "\tОшибка открытия файла '%s'\n", output_file);
            _exit(80);
            /* Код 80 означает завершение работы программы, вызванное ошибкой при 
               создании файла вывода output_file. */
        }
        // Если новый дескриптор не соответствует стандартному выводу,
        if (fd != STDOUT_FILENO)
        {
            /* то СВ dup2() вынуждает стандартный вывод стать дубликатом нового
               дескриптора (если дескриптор STDOUT_FILENO перед вызовом dup2() уже был
               открыт, он предварительно закрывается), */
            dup2_eh(fd, STDOUT_FILENO);
            // затем новый дескриптор закрывается за ненадобностью:
            close_eh(fd);
        }                                                               
        
        /* Затем процесс-потомок выводит в файл output_file полученные от родителя 
           результаты поиска в файле name подстроки substring.
           Если подстрока не была найдена, то файл вывода окажется пустым: */
        if (found_strings == 0)
        {
             _exit(0);
             /* СВ _exit() немедленно завершает процесс-потомок, закрывая все открытые 
                в процессе файлы, включая файл вывода, связанный с пользовательским 
                дескриптором стандартного вывода STDOUT_FILENO. Код 0 означает правильное 
                завершение процесса-потомка. */
        }
        /* Если было обнаружено хотя бы одно вхождение подстроки, то процесс-потомок 
           посредством СВ execv() запускает утилиту sed с внешними аргументами, 
           переданными процессом-родителем. Результаты поиска подстроки (вывод утилиты 
           sed) записываются в файл output_file: */
        else
        {
            /*
            Для формирования команды, включающей имя программы и множество ее внешних 
            аргументов, использовался символьный массив command, как это было предложено 
            в лекции 3.2 "Информационные связи между параллельными процессами", 
            3 мин. 51 сек. Символьный массив command вместе с именем программы содержит 
            command_args_count-1 аргументов, разделенных между собой пробелами. Последний 
            аргумент под номером command_args_count - это имя файла name, оно будет 
            добавлено к внешним аргументам утилиты sed отдельно.
            Несколько внешних аргументов посредством одного символьного массива можно 
            передать лишь в СВ system(). В данном случае нужно использовать СВ группы 
            exec(), внешние аргументы в которые передаются списком или массивом 
            указателей.
            СВ execl(), принимающий список аргументов, полезен только для вызова программ 
            с фиксированным числом аргументов (или, по крайней мере, когда существует 
            небольшая фиксированная верхняя граница числа аргументов).          
            Лучшим выбором в случаях, когда аргументы определяются во время выполнения 
            программы, является execv(). Для того, чтобы передать произвольное число 
            аргументов в СВ execv(), нужно создать массив указателей arg_ptr на 
            символьные массивы с аргументами командной строки (по одному указателю 
            на каждый аргумент и один завершающий). Как и в случае с аргументами в виде 
            списка переменной длины, массив указателей должен заканчиваться значением 
            NULL.
            Итак, должно присутствовать как минимум 2 аргумента: имя программы, которое 
            отобразится в элемент arg_ptr[0] и нулевой указатель в конце массива, чтобы 
            СВ execv() смог определить, какой именно аргумент является последним. 
            Преобразование символьного массива command под формат внешних аргументов 
            СВ execv() и создание массива указателей на аргументы:
            */
            char *arg_ptr[command_args_count + 1];      /* Массив указателей arg_ptr
                                                           на символьные массивы
                                                           с аргументами командной строки. */
            arg_ptr[0] = command;                       /* Первый указатель - имя 
                                                           программы. */
            arg_ptr[command_args_count - 1] = name;     // Предпоследний - имя файла.
            arg_ptr[command_args_count] = (char *)NULL; /* Последний - обязательный 
                                                           завершающий нулевой указатель. */
            int args_done = 1;                          /* Количество заполненных 
                                                           указателей на аргументы из 
                                                           массива command (два последних 
                                                           на массив command не указывают,
                                                           поэтому они и не учитываются). */
            size_t i = 0;                               /* Индекс просмотра символьного 
                                                           массива command. 
            Разделение всех аргументов в массиве command нулевыми символами: */
            while (args_done < command_args_count - 1)
            {
                /* Если встретился символ пробела, то он находится между двумя соседними 
                аргументами */
                if (command[i] == ' ')
                {
                    // На следующий за пробелом символ выставляется очередной указатель,
                    arg_ptr[args_done++] = &command[i + 1];
                    // а пробел заменяется нулевым символом, обозначающим конец строки:
                    command[i] = '\0';
                }
                i++; // Переход к следующему символу
            }
            /* Выделенная под символьный массив command область памяти теперь содержит 
               разделенные нулевыми символами имя программы (нулевой аргумент) и 
               множество её внешних аргументов, а элементы массива указателей arg_ptr 
               ссылаются на эти аргументы.
               Адрес массива указателей передается в качестве аргумента одному из 
               СВ exec(), заканчивающемуся на букву v. Эти вызовы удобны, когда число 
               аргументов вызываемой программы неизвестно заранее.
               В рамках процесса-потомка СВ exec() создает новый процесс, запуская 
               утилиту sed, данные в которую передаются через внешние аргументы. 
               Результат своей работы утилита sed записывает в стандартный вывод, 
               то есть в файл output_file вместо экрана монитора: */
            execv("/usr/bin/sed", arg_ptr);
            /* Поскольку СВ execv() убивает процесс, в рамках которого он был запущен,
               т.е. вызывает новую программу вместо уже выполняющейся без возврата 
               в вызывающую программу, то дальнейшие строки кода будут выполнены лишь
               в случае, если утилиту sed запустить не удалось: */
            /* Обработка ошибки */
            fprintf(stderr, "\tОшибка вызова exec. Невозможно запустить'%s'\n", arg_ptr[0]);
            _exit(127);
            /* СВ _exit() немедленно завершает процесс-потомок, закрывая все открытые 
               в процессе файлы, включая файл вывода, связанный с пользовательским 
               дескриптором стандартного вывода STDOUT_FILENO. Код 127 означает 
               завершение работы процесса-потомка, вызванное ошибкой СВ execv(). */
        }
        break; // Ветка для потомка
    default: /* Ветка для родителя после успешного вызова fork(): */
        /* Родитель приостанавливает свою работу и ждет завершения процесса-потомка, 
           вызвав wait(): */
        if (wait(&status) == -1) // Если СВ wait() завершился неудачей:
        {
            /* Обработка ошибки */
            fprintf(stderr, "\tОшибка вызова wait\n");
            _exit(90);
            // Код 90 означает завершение работы программы, вызванное ошибкой СВ wait().
        }
        /* Если вызов wait() завершился успешно, то он записывает в аргумент status код
           завершения процесса-потомка, после чего процесс-родитель выполняет проверки
           этого кода: */
        if (WIFEXITED(status)) /* Проверка нормального завершения процесса-потомка.
                                  В этом случае можно узнать код завершения потомка: */
        {
            int exit_status = WEXITSTATUS(status); /* Извлечение младших 8 бит из 
                                                      аргумента, который был передан 
                                                      потомком в функцию exit() или СВ 
                                                      _exit(). */
            if (exit_status == 0) // Если оба вызова wait() и execv() завершились удачно
            {
                printf("\tРезультаты записаны в файл '%s'\n", output_file);
            }
            else /* Если СВ wait() завершился удачно, но в процессе работы потомка 
                    возникла какая-то ошибка, код которой был передан потомком в функцию 
                    exit() или СВ _exit() */
            {
                fprintf(stderr, "\tПроцесс-потомок завершился с ошибкой, код выхода = %d\n", exit_status);
            }
            _exit(exit_status);
            /* Код 0 означает правильное завершение программы, другое значение кода
               означает завершение работы программы, вызванное ошибкой в работе потомка. */
        }
        else if (WIFSIGNALED(status)) /* Проверка ненормального (аварийного) завершения 
                                         потомка из-за полученного им сигнала, который 
                                         не был перехвачен. В этом случае можно узнать 
                                         номер сигнала, вызвавшего завершение 
                                         процесса-потомка. */
        {
            fprintf(stderr, "\tАварийное завершение процесса-потомка, номер сигнала = %d%s\n", WTERMSIG(status),
#ifdef WCOREDUMP /* В некоторых реализациях ОС UNIX определен макрос WCOREDUMP, который 
                    возвращает true, если в результате аварийного завершения процесса 
                    создан файл с дампом памяти (core-файл): */
            WCOREDUMP(status) ? " (создан файл core с образом памяти процесса)" : "");
#else
            "");
#endif
            _exit(130);
            /* Код 130 означает завершение работы программы с ошибкой, вызванной  
               аварийным завершением процесса-потомка. */
        }

        else if (WIFSTOPPED(status)) /* Проверка остановки процесса потомка. В этом 
                                        случае можно узнать номер сигнала, который вызвал
                                        остановку процесса. */
        {
            fprintf(stderr, "\tПроцесс-потомок остановлен, номер сигнала = %d\n", WSTOPSIG(status));
            _exit(133);
            /* Код 133 означает завершение работы программы с ошибкой, вызванной 
               остановкой процесса-потомка по сигналу. */
        }
    }
}
